<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Availability</title>
    <style>
        body {
            font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1a1a1a;
            margin: 0;
            padding: 20px;
        }
        .main-container {
            max-width: 800px;
            margin: auto;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
        }
        .container-block {
            background-color: #fdfdfd;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2em;
            font-weight: bold;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
            text-align: left;
        }
        h2 {
            font-size: 1.5em;
            font-weight: 600;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-top: 0;
        }
        h3 {
            font-size: 1.25em;
            font-weight: 600;
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }
        /* Form Elements */
        input[type="text"],
        input[type="date"],
        input[type="time"],
        input[type="number"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box; /* Important */
            font-size: 1em;
            background-color: #fff;
        }
        label {
            display: block;
            font-weight: 500;
            margin-bottom: 5px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            opacity: 0.85;
        }
        /* Form Layout */
        .form-grid-2 {
            display: grid;
            grid-template-columns: 1fr; /* Default to 1 column */
            gap: 15px;
            margin-bottom: 15px;
        }
        /* Media query for larger screens */
        @media (min-width: 640px) {
            .form-grid-2 {
                grid-template-columns: 1fr 1fr; /* 2 columns on sm screens and up */
            }
        }
        .form-group {
            margin-bottom: 15px;
        }
        /* Specific Buttons */
        .btn-green { background-color: #28a745; color: white; }
        .btn-red { background-color: #dc3545; color: white; }
        .btn-purple { background-color: #6f42c1; color: white; }
        .btn-blue { background-color: #007bff; color: white; }
        .btn-gray { background-color: #6c757d; color: white; }
        .btn-light { background-color: #f8f9fa; color: #212529; border: 1px solid #ddd; }
        .btn-delete-mini {
            padding: 3px 8px;
            font-size: 0.8em;
            background-color: #dc3545;
            color: white;
            border-radius: 4px;
        }
        /* Status Messages */
        .status {
            font-style: italic;
            font-size: 0.9em;
            color: #555;
            margin-top: 10px;
            display: none; /* Hidden by default */
        }
        .status-visible { display: block; }
        .status-error { color: #dc3545; font-weight: 600; }
        .status-success { color: #28a745; font-weight: 600; }
        
        /* Teacher Lists */
        .teacher-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            list-style: none;
            padding: 0;
            margin-top: 10px;
        }
        .teacher-list li {
            padding: 6px 10px;
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.9em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .teacher-available { background-color: #28a745; color: white; }
        .teacher-on-call { background-color: #ffc107; color: #212529; }
        .teacher-absent {
            background-color: #6c757d;
            color: #eee;
            text-decoration: line-through;
            opacity: 0.7;
        }
        /* Absence List */
        #existing-absences-list h4 {
            margin-bottom: 5px;
            margin-top: 15px;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
            font-size: 1.1em;
            font-weight: 600;
        }
        #existing-absences-list ul {
            padding-left: 0;
            margin-top: 5px;
            list-style: none;
        }
        #existing-absences-list li {
            margin-bottom: 8px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        /* Totals Table */
        #totals-display {
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            min-height: 80px;
            overflow-x: auto;
        }
        #totals-table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #ccc;
        }
        #totals-table th, #totals-table td {
            padding: 8px;
            border: 1px solid #ccc;
            text-align: left;
        }
        #totals-table th {
            background-color: #f1f1f1;
            font-weight: 600;
        }
        #totals-table tr:last-child {
            font-weight: bold;
            background-color: #f8f8f8;
        }
        /* Month Buttons */
        #month-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 15px;
        }
        #month-buttons button {
            background-color: #e9ecef;
            color: #333;
            font-size: 0.85em;
            padding: 5px 10px;
        }
        #month-buttons button.active-month {
            background-color: #007bff;
            color: white;
        }
        /* Filter */
        .filter-input {
            margin-bottom: 15px;
            width: 100%;
            max-width: 300px; /* Limit filter width */
        }
        .filtered-hide {
            display: none !important;
        }
        /* Button Groups */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        .hidden { display: none; }
        .logo {
            width: 160px;
            height: auto;
            margin-bottom: 15px;
            display: block; /* Make it a block element */
            margin-left: 0; /* Align left by default */
        }
        @media (max-width: 640px) {
            .logo {
                margin-left: auto; /* Center on small screens */
                margin-right: auto;
            }
            h1 {
                text-align: center;
            }
        }
     </style>
</head>
<body>

    <div class="main-container">

        <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
        <h1>Teacher Availability</h1>

        <!-- Available Now Container -->
        <div class="container-block">
            <h2>Available Right Now</h2>
            <div id="status-now" class="status status-visible">Loading schedule...</div>
            <span id="last-updated" style="font-size: 0.8em; color: #555; display: block; margin-bottom: 10px;"></span>
            <!-- Filter Input for Available Now -->
            <input type="text" id="filter-now" placeholder="Filter by name..." class="filter-input">
            <div id="results-now"><ul id="teachers-now" class="teacher-list"></ul></div>
        </div>

        <!-- Check Availability Container -->
        <div class="container-block">
            <h2>Check Availability for a Time Range</h2>
            <div class="form-group">
                <label for="date-input">Date:</label>
                <input type="date" id="date-input">
            </div>
            <div class="form-grid-2">
                <div>
                    <label for="time-from-input">Time (From):</label>
                    <input type="time" id="time-from-input">
                </div>
                <div>
                    <label for="time-to-input">Time (To):</label>
                    <input type="time" id="time-to-input">
                </div>
            </div>
            <button id="check-button" class="btn-green">Check Availability</button>
            <div id="status-custom" class="status"></div>
            <!-- Filter Input for Custom Range -->
            <input type="text" id="filter-custom" placeholder="Filter by name..." class="filter-input" style="margin-top: 15px;">
            <div id="results-custom"><ul id="teachers-custom" class="teacher-list"></ul></div>
        </div>

        <!-- Log Staff Absence Container -->
        <div class="container-block">
            <h2>Log Staff Absence (Training, Meetings, etc.)</h2>
            <p style="font-size: 0.9em; color: #555; margin-bottom: 15px;">Log a time range when a staff member is unavailable. This will remove them from the availability lists for that specific time.</p>
            <div class="form-grid-2">
                <div>
                    <label for="absence-staff-select">Staff Member:</label>
                    <select id="absence-staff-select">
                        <option value="">-- Select Staff --</option>
                    </select>
                </div>
                <div>
                    <label for="absence-date-input">Date of Absence:</label>
                    <input type="date" id="absence-date-input">
                </div>
            </div>
            <div class="form-grid-2">
                <div>
                    <label for="absence-time-from-input">Time (From):</label>
                    <input type="time" id="absence-time-from-input">
                </div>
                <div>
                    <label for="absence-time-to-input">Time (To):</label>
                    <input type="time" id="absence-time-to-input">
                </div>
            </div>
            <button id="save-absence-button" class="btn-green">Save Absence Entry</button>
            <div id="absence-save-status" class="status"></div>
            
            <!-- Existing Absences -->
            <input type="text" id="filter-absences" placeholder="Filter by name..." class="filter-input" style="margin-top: 20px;">
            <h3>Existing Absences for Selected Day</h3>
            <div id="existing-absences-list" style="font-size: 0.9em;">
                <p class="status status-visible">Select a date to see existing entries.</p>
            </div>

            <!-- Absence Import/Export Buttons -->
            <div class="button-group">
                 <button id="export-absences-button" class="btn-purple">Export Absences CSV</button>
                 <button id="import-absences-button" class="btn-light">Import Absences CSV</button>
                 <input type="file" id="absence-csv-file-input" class="hidden">
            </div>
              <div id="absence-import-status" class="status"></div>
        </div>

        <!-- Extra Minutes Tracker Container -->
        <div class="container-block">
            <h2>Extra Minutes Tracker</h2>
            <p style="font-size: 0.9em; color: #555; margin-bottom: 15px;">Record extra minutes worked by staff. This data is saved in your browser.</p>
            <div class="form-grid-2">
                <div>
                    <label for="staff-select">Staff Member:</label>
                    <select id="staff-select">
                        <option value="">-- Select Staff --</option>
                    </select>
                </div>
                <div>
                    <label for="date-entry-input">Date Worked:</label>
                    <input type="date" id="date-entry-input">
                </div>
            </div>
            <div class="form-group">
                <label for="minutes-input">Add Extra Minutes:</label>
                <input type="number" id="minutes-input" placeholder="e.g., 60">
            </div>
            <button id="save-minutes-button" class="btn-green">Save Minutes</button>
            <div id="save-status" class="status"></div>
        </div>

        <!-- Extra Minutes Totals Container -->
        <div class="container-block">
            <h2>Extra Minutes Totals</h2>
            <div class="form-group" style="max-width: 200px;">
                <label for="year-display">Select Year:</label>
                <input type="number" id="year-display" value="2025">
            </div>
            <!-- Month Buttons - dynamically populated -->
            <div id="month-buttons"></div> 
            
            <!-- Totals Display Area - Will be replaced by table -->
            <div id="totals-display"> 
                <p class="status status-visible">Select a month to see totals.</p>
            </div>
            
            <!-- Minutes Import/Export/Clear Buttons -->
            <div class="button-group">
                <button id="export-backup-button" class="btn-purple">Export CSV (Min)</button> 
                <button id="export-summary-button" class="btn-blue">Summary CSV (Min)</button>    
                <button id="import-csv-button" class="btn-light">Import CSV (Min)</button>     
                <input type="file" id="csv-file-input" class="hidden">
                <button id="clear-data-button" class="btn-red">Clear All Saved Data</button>
            </div>
            <div id="import-status" class="status"></div>
        </div>

    </div> <!-- End Main content container -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed."); // Log DOM readiness

            // --- Global Variables ---
            let lessons = [];
            let allTeachers = new Set();
            let columnMap = {};
            let activeMonthButton = null;
            let refreshIntervalId = null; 

            // --- CONFIGURATION ---
            const dayMap = ["Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat"];
            const ARBETSTID_SUBJECT = "arbetstid";
            const ON_CALL_SUBJECT = "on call substitution";
            const REFRESH_INTERVAL_MS = 60000; 
            const MINUTES_STORAGE_KEY = 'teacherMinutesData'; 
            const ABSENCE_STORAGE_KEY = 'teacherAbsenceData';
            const EXCLUDE_TEACHER_LIST = ["BaSh", "AnHo", "DaWr", "AniFac", "RahHan", "ChBe", "FaCa", "SeCa", "AlCh", "LaCo", "VikCos", "RoDi", "KrEr", "RaHa", "JeHe", "DiHe", "GaHe", "HeKa", "JoLe", "TiLe", "WiLi", "ChLi", "HaLu", "KaMa", "ViMe", "MaMe", "HiOj", "LePa", "AsRo", "RaSc", "TaSc", "JeSe", "AnVa", "MarMen", "JonLeh"];
            const EXCLUDE_TEACHERS_SET = new Set(EXCLUDE_TEACHER_LIST);
            // ---------------------

            // --- Get DOM Elements ---
            const statusNow = document.getElementById('status-now');
            const teachersNowList = document.getElementById('teachers-now');
            const lastUpdatedSpan = document.getElementById('last-updated');
            const statusCustom = document.getElementById('status-custom');
            const teachersCustomList = document.getElementById('teachers-custom');
            const checkButton = document.getElementById('check-button');
            const dateInput = document.getElementById('date-input');
            const timeFromInput = document.getElementById('time-from-input');
            const timeToInput = document.getElementById('time-to-input');
            const staffSelect = document.getElementById('staff-select');
            const dateEntryInput = document.getElementById('date-entry-input');
            const minutesInput = document.getElementById('minutes-input');
            const saveMinutesButton = document.getElementById('save-minutes-button');
            const saveStatus = document.getElementById('save-status');
            const yearDisplay = document.getElementById('year-display');
            const monthButtonsContainer = document.getElementById('month-buttons');
            const totalsDisplay = document.getElementById('totals-display');
            const exportSummaryButton = document.getElementById('export-summary-button');
            const exportBackupButton = document.getElementById('export-backup-button');
            const clearDataButton = document.getElementById('clear-data-button');
            const importCsvButton = document.getElementById('import-csv-button');
            const csvFileInput = document.getElementById('csv-file-input');
            const importStatus = document.getElementById('import-status');
            const absenceStaffSelect = document.getElementById('absence-staff-select');
            const absenceDateInput = document.getElementById('absence-date-input');
            const absenceTimeFromInput = document.getElementById('absence-time-from-input');
            const absenceTimeToInput = document.getElementById('absence-time-to-input');
            const saveAbsenceButton = document.getElementById('save-absence-button');
            const absenceSaveStatus = document.getElementById('absence-save-status');
            const existingAbsencesList = document.getElementById('existing-absences-list');
            const exportAbsencesButton = document.getElementById('export-absences-button');
            const importAbsencesButton = document.getElementById('import-absences-button');
            const absenceCsvFileInput = document.getElementById('absence-csv-file-input');
            const absenceImportStatus = document.getElementById('absence-import-status');
            // Filter Inputs
            const filterNowInput = document.getElementById('filter-now');
            const filterCustomInput = document.getElementById('filter-custom');
            const filterAbsencesInput = document.getElementById('filter-absences');

            // --- Initial Checks ---
             if (!statusNow || !lastUpdatedSpan || !monthButtonsContainer || !staffSelect || !absenceStaffSelect || !exportAbsencesButton || !importAbsencesButton || !absenceCsvFileInput || !absenceImportStatus || !filterNowInput || !filterCustomInput || !filterAbsencesInput ) { 
                 console.error("Critical DOM element missing! Cannot proceed.", { statusNow, lastUpdatedSpan, monthButtonsContainer, staffSelect, absenceStaffSelect, exportAbsencesButton, importAbsencesButton, absenceCsvFileInput, absenceImportStatus, filterNowInput, filterCustomInput, filterAbsencesInput });
                 if (statusNow) { 
                     statusNow.textContent = "Error: Page structure broken."; 
                     statusNow.className = 'status status-visible status-error';
                } 
                 return; 
             }
             console.log("All critical DOM elements found.");

            // --- Utility Functions ---
            function getIsoWeekAndYear(d) {
                // Creates a new date object from the input date, forcing UTC interpretation
                d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                // Move date to Thursday of the same week
                d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
                // Get the start of the year
                var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
                // Check for Timezone offset differences in case of DST changes
                if (yearStart.getTimezoneOffset() !== d.getTimezoneOffset()) {
                   // Adjust yearStart time if timezone offset is different
                   yearStart.setUTCHours(d.getHours() + (d.getTimezoneOffset() - yearStart.getTimezoneOffset()) / 60);
                }
                // Calculate week number
                var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                return { year: d.getUTCFullYear(), week: weekNo };
            }
            
            function timeToMinutes(timeStr) {
                 if (!timeStr) return 0;
                 const [hours, minutes] = timeStr.split(':').map(Number);
                 return (hours || 0) * 60 + (minutes || 0);
            }
            
            function minutesToHHMM(totalMinutes) {
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }

            function parseRealWeeks(weekString) {
                const weeks = new Set();
                if (!weekString) return weeks;
                const parts = weekString.split(',');
                parts.forEach(part => {
                    part = part.trim();
                    if (part.includes('-')) {
                        const [start, end] = part.split('-').map(Number);
                        if (!isNaN(start) && !isNaN(end)) {
                            for (let i = start; i <= end; i++) {
                                weeks.add(i);
                            }
                        }
                    } else {
                        const weekNum = parseInt(part, 10);
                        if (!isNaN(weekNum)) {
                            weeks.add(weekNum);
                        }
                    }
                });
                return weeks;
            }
            
            function parseTeachers(teacherString) {
                 if (!teacherString) return [];
                 // Split by " / " and filter out any empty strings that might result
                 return teacherString.split(' / ').map(t => t.trim()).filter(t => t.length > 0);
            }

            function parseCsvLine(line) {
                // Regex to handle quoted fields, including escaped quotes ("")
                const regex = /(?:"([^"]*(?:""[^"]*)*)"|([^,]*))(?:,|$)/g;
                const values = [];
                let match;
                while (match = regex.exec(line)) {
                    if (match[1] !== undefined) {
                        // Field was quoted
                        values.push(match[1].replace(/""/g, '"'));
                    } else {
                        // Field was not quoted
                        values.push(match[2] || '');
                    }
                    if (match[0].slice(-1) !== ',') break; // End of line
                }
                return values;
            }

            function dateToYYYYMMDD(dateObj) {
                // Ensures date is formatted as YYYY-MM-DD regardless of timezone
                return dateObj.toISOString().split('T')[0];
            }

            // --- Local Storage Functions ---
            function getSavedMinutesData() {
                try {
                    const data = localStorage.getItem(MINUTES_STORAGE_KEY);
                    return data ? JSON.parse(data) : {};
                } catch (e) {
                    console.error("Error reading minutes from localStorage:", e);
                    return {}; // Return empty object on error
                }
            }

            function saveMinutesData(data) {
                try {
                    localStorage.setItem(MINUTES_STORAGE_KEY, JSON.stringify(data));
                } catch (e) {
                    console.error("Error saving minutes to localStorage:", e);
                }
            }

            function getSavedAbsenceData() {
                 try {
                    const data = localStorage.getItem(ABSENCE_STORAGE_KEY);
                    return data ? JSON.parse(data) : {};
                } catch (e) {
                    console.error("Error reading absences from localStorage:", e);
                    return {};
                }
            }
            
            function saveAbsenceData(data) {
                 try {
                    localStorage.setItem(ABSENCE_STORAGE_KEY, JSON.stringify(data));
                } catch (e) {
                    console.error("Error saving absences to localStorage:", e);
                }
            }

            // --- Status Update Functions ---
            function showSaveStatus(message, isError = false) {
                saveStatus.textContent = message;
                saveStatus.className = 'status status-visible'; // Base classes
                if (isError) { 
                    saveStatus.classList.add('status-error'); 
                } else { 
                    saveStatus.classList.add('status-success'); 
                }
                setTimeout(() => { saveStatus.className = 'status'; }, 3000); // Hide after 3s
            }

            function showImportStatus(message, isError = false) {
                importStatus.textContent = message;
                importStatus.className = 'status status-visible';
                if (isError) { 
                    importStatus.classList.add('status-error'); 
                } else { 
                    importStatus.classList.add('status-success'); 
                }
                setTimeout(() => { importStatus.className = 'status'; }, 5000);
            }
            
            function showAbsenceSaveStatus(message, isError = false) {
                absenceSaveStatus.textContent = message;
                absenceSaveStatus.className = 'status status-visible';
                if (isError) { 
                    absenceSaveStatus.classList.add('status-error'); 
                } else { 
                    absenceSaveStatus.classList.add('status-success'); 
                }
                setTimeout(() => { absenceSaveStatus.className = 'status'; }, 3000);
            }

            function showAbsenceImportStatus(message, isError = false) {
                absenceImportStatus.textContent = message;
                absenceImportStatus.className = 'status status-visible';
                if (isError) { 
                    absenceImportStatus.classList.add('status-error'); 
                } else { 
                    absenceImportStatus.classList.add('status-success'); 
                }
                setTimeout(() => { absenceImportStatus.className = 'status'; }, 5000);
            }
            
            // --- Availability Logic ---
            function getAvailabilityAtTime(dateTime) {
                const defaultResult = { available: [], onCallTimes: new Map() };
                try {
                    if (!Array.isArray(lessons) || lessons.length === 0) { 
                        console.log("getAvailabilityAtTime: No lessons loaded."); 
                        return defaultResult; 
                    }
                    
                    const weekInfo = getIsoWeekAndYear(dateTime);
                    if (!weekInfo) { 
                        console.error("getIsoWeekAndYear failed in getAvailabilityAtTime"); 
                        return defaultResult; 
                    }
                    const { week: currentWeekNum } = weekInfo;
                    
                    const currentDay = dayMap[dateTime.getDay()];
                    const currentTimeInMinutes = dateTime.getHours() * 60 + dateTime.getMinutes();
                    
                    let workingTeachers = new Set();
                    const onCallTimesMap = new Map();
                    let busyTeachers = new Set();
                    
                    lessons.forEach(lesson => {
                        try {
                            const lessonDay = lesson[columnMap['day']]?.trim();
                            const weekString = lesson[columnMap['realweeks']];
                            const subject = lesson[columnMap['subject']]?.trim().toLowerCase();
                            const startStr = lesson[columnMap['starttime']];
                            const lenStr = lesson[columnMap['length']];
                            const teacherStr = lesson[columnMap['teacher']];
                            
                            if (!lessonDay || !weekString || !subject || !startStr || !lenStr) return;
                            
                            const lessonWeeks = parseRealWeeks(weekString);
                            if (lessonDay !== currentDay || !lessonWeeks.has(currentWeekNum)) return;
                            
                            const lessonStart = timeToMinutes(startStr);
                            const lessonLength = parseInt(lenStr, 10);
                            if (isNaN(lessonLength) || lessonLength <= 0) return;
                            const lessonEnd = lessonStart + lessonLength;
                            const teachers = parseTeachers(teacherStr);
                            
                            const isHappeningNow = (currentTimeInMinutes >= lessonStart && currentTimeInMinutes < lessonEnd);
                            
                            if (subject === ARBETSTID_SUBJECT) {
                                if (isHappeningNow) {
                                    teachers.forEach(t => workingTeachers.add(t));
                                }
                            } else if (subject === ON_CALL_SUBJECT) {
                                if (isHappeningNow) {
                                    teachers.forEach(t => {
                                        workingTeachers.add(t);
                                        if (!onCallTimesMap.has(t)) {
                                            onCallTimesMap.set(t, { start: lessonStart, end: lessonEnd });
                                        }
                                    });
                                }
                            } else if (isHappeningNow) {
                                teachers.forEach(t => busyTeachers.add(t));
                            }
                        } catch (e) {
                            console.error("Error processing lesson row (getAvailabilityAtTime):", lesson, e);
                        }
                    });
                    
                    let availableAndNotBusy = [...workingTeachers].filter(teacher => !busyTeachers.has(teacher));
                    // Check absence status against the current time
                    let availableTeacherNames = availableAndNotBusy.filter(teacher => !isTeacherAbsent(teacher, dateTime, currentTimeInMinutes));
                    
                    return { available: availableTeacherNames.sort(), onCallTimes: onCallTimesMap };
                } catch (error) {
                    console.error("Critical Error in getAvailabilityAtTime:", error);
                    return defaultResult;
                }
            }

            function getAvailabilityForRange(checkDate, checkStartMinutes, checkEndMinutes) {
                const defaultResult = { available: [], onCallTimes: new Map() };
                try {
                    if (!Array.isArray(lessons) || lessons.length === 0) { 
                        console.log("getAvailabilityForRange: No lessons."); 
                        return defaultResult; 
                    }
                    let workingTeachers = new Set(); 
                    const onCallTimesMap = new Map(); 
                    const busyTeachers = new Set();
                    
                    const weekInfo = getIsoWeekAndYear(checkDate); 
                    if (!weekInfo) { 
                        console.error("getIsoWeekAndYear failed in getAvailabilityForRange"); 
                        return defaultResult; 
                    } 
                    const { week: checkWeekNum } = weekInfo;
                    const checkDay = dayMap[checkDate.getDay()];
                    
                    lessons.forEach(lesson => {
                        try { 
                            const lessonDay = lesson[columnMap['day']]?.trim(); 
                            const weekString = lesson[columnMap['realweeks']]; 
                            const subject = lesson[columnMap['subject']]?.trim().toLowerCase(); 
                            const startStr = lesson[columnMap['starttime']]; 
                            const lenStr = lesson[columnMap['length']]; 
                            const teacherStr = lesson[columnMap['teacher']]; 
                            
                            if (!lessonDay || !weekString || !subject || !startStr || !lenStr) return; 
                            
                            const lessonWeeks = parseRealWeeks(weekString); 
                            if (lessonDay !== checkDay || !lessonWeeks.has(checkWeekNum)) return; 
                            
                            const lessonStart = timeToMinutes(startStr); 
                            const lessonLength = parseInt(lenStr, 10); 
                            if (isNaN(lessonLength) || lessonLength <= 0) return; 
                            const lessonEnd = lessonStart + lessonLength; 
                            const teachers = parseTeachers(teacherStr); 
                            
                            // Check if lesson *fully contains* the query range
                            const containsQuery = (lessonStart <= checkStartMinutes && lessonEnd >= checkEndMinutes); 
                            // Check if lesson *overlaps at all* with the query range
                            const overlapsQuery = (lessonStart < checkEndMinutes && lessonEnd > checkStartMinutes); 
                            
                            if (subject === ARBETSTID_SUBJECT) { 
                                if (containsQuery) teachers.forEach(t => workingTeachers.add(t)); 
                            } else if (subject === ON_CALL_SUBJECT) { 
                                if (containsQuery) { 
                                    teachers.forEach(t => { 
                                        workingTeachers.add(t); 
                                        if (!onCallTimesMap.has(t)) { 
                                            onCallTimesMap.set(t, { start: lessonStart, end: lessonEnd }); 
                                        } 
                                    }); 
                                } 
                            } else if (overlapsQuery) { // Any other lesson that overlaps makes them busy
                                teachers.forEach(t => busyTeachers.add(t)); 
                            } 
                        } catch (e) { console.error("Error processing lesson row (getAvailabilityForRange):", lesson, e); }
                    });
                    
                    let availableAndNotBusy = [...workingTeachers].filter(teacher => !busyTeachers.has(teacher));
                    // Check absence status at the *start* of the requested range
                    let availableTeacherNames = availableAndNotBusy.filter(teacher => !isTeacherAbsent(teacher, checkDate, checkStartMinutes));
                    
                    return { available: availableTeacherNames.sort(), onCallTimes: onCallTimesMap }; // Successful return
                } catch (error) { 
                    console.error("Critical Error in getAvailabilityForRange:", error); 
                    statusCustom.textContent = `Error calculating availability: ${error.message}`; 
                    statusCustom.className = 'status status-visible status-error';
                    return defaultResult; // Return default on catch
                }
            }
            
            function isTeacherAbsent(teacher, checkDate, checkTimeInMinutes) {
                const dateKey = dateToYYYYMMDD(checkDate);
                const absenceData = getSavedAbsenceData();
                const dayAbsences = absenceData[dateKey];

                if (dayAbsences && dayAbsences[teacher]) {
                    for (const entry of dayAbsences[teacher]) {
                        // Check if the checkTime falls within any absence range
                        if (checkTimeInMinutes >= entry.start && checkTimeInMinutes < entry.end) {
                            return true; // Teacher is absent
                        }
                    }
                }
                return false; // Teacher is not absent
            }

            // --- UI Update Functions ---
            function displayResults(availableTeachers, onCallTimesMap, listElement, statusElement, checkDate) {
                listElement.innerHTML = ''; // Clear previous results
                const dateKey = checkDate ? dateToYYYYMMDD(checkDate) : null;
                const absenceData = getSavedAbsenceData();
                const dayAbsences = dateKey ? (absenceData[dateKey] || {}) : {};

                if (availableTeachers.length === 0) {
                    statusElement.textContent = 'No teachers found available for the selected criteria.';
                    statusElement.className = 'status status-visible'; // Reset to default
                    return;
                }

                // Separate On Call from regular available
                const onCallTeachers = [];
                const regularTeachers = [];

                availableTeachers.forEach(teacher => {
                    if (onCallTimesMap.has(teacher)) {
                        onCallTeachers.push(teacher);
                    } else {
                        regularTeachers.push(teacher);
                    }
                });

                // Function to create a list item
                const createTeacherLi = (teacher) => {
                    const onCallInfo = onCallTimesMap.get(teacher);
                    const li = document.createElement('li');
                    li.textContent = teacher;
                    
                    // Check for absence
                    let isAbsent = false;
                    if (dayAbsences[teacher]) {
                        // For "now", check current time. For "range", check start of range.
                        let checkTime;
                        if (listElement === teachersNowList) {
                             checkTime = new Date().getHours() * 60 + new Date().getMinutes();
                        } else {
                             checkTime = onCallInfo ? onCallInfo.start : timeToMinutes(timeFromInput.value);
                             if (isNaN(checkTime) && checkDate) { // Fallback for "now"
                                checkTime = checkDate.getHours() * 60 + checkDate.getMinutes();
                             }
                        }
                        
                        // We re-use the isTeacherAbsent function for a definitive check
                        isAbsent = isTeacherAbsent(teacher, checkDate, checkTime);
                    }

                    if (onCallInfo) {
                        // Style for On Call
                        const onCallStart = minutesToHHMM(onCallInfo.start);
                        const onCallEnd = minutesToHHMM(onCallInfo.end);
                        li.textContent += ` (On Call ${onCallStart}-${onCallEnd})`;
                        li.className = 'teacher-on-call';
                    } else {
                        // Style for Available
                        li.className = 'teacher-available';
                    }
                    
                    // Override styling if absent
                    if (isAbsent && listElement === teachersNowList) { 
                        // Only strike-through if it's the "now" list
                        li.textContent += ' (Absent)';
                        li.className = 'teacher-absent';
                    }
                    
                    return li;
                };

                // Add regular teachers first, then on-call teachers
                regularTeachers.forEach(teacher => listElement.appendChild(createTeacherLi(teacher)));
                onCallTeachers.forEach(teacher => listElement.appendChild(createTeacherLi(teacher)));
                
                let timeStr;
                if (listElement === teachersNowList) {
                    timeStr = `as of ${new Date().toLocaleTimeString()}`;
                } else {
                    timeStr = `for ${checkDate.toDateString()} from ${timeFromInput.value} to ${timeToInput.value}`;
                }
                
                statusElement.textContent = `Found ${availableTeachers.length} available teachers ${timeStr}.`;
                statusElement.className = 'status status-visible'; // Reset to default
            }

            function displayExistingAbsences(dateKey) {
                const absenceData = getSavedAbsenceData();
                const dayAbsences = absenceData[dateKey];
                existingAbsencesList.innerHTML = ''; // Clear previous

                if (!dayAbsences || Object.keys(dayAbsences).length === 0) {
                    existingAbsencesList.innerHTML = `<p class="status status-visible">No absences logged for ${dateKey}.</p>`;
                    return;
                }

                // Group by teacher
                const sortedTeachers = Object.keys(dayAbsences).sort();
                
                for (const teacher of sortedTeachers) {
                    const entries = dayAbsences[teacher];
                    if (entries && entries.length > 0) {
                        // Create a group container for filtering
                        const groupDiv = document.createElement('div');
                        groupDiv.setAttribute('data-teacher-name', teacher.toLowerCase());
                        groupDiv.className = 'absence-group';

                        const heading = document.createElement('h4');
                        heading.textContent = teacher;
                        groupDiv.appendChild(heading);
                        
                        const ul = document.createElement('ul');
                        entries.forEach(entry => {
                            const li = document.createElement('li');
                            
                            const textSpan = document.createElement('span');
                            textSpan.textContent = `${minutesToHHMM(entry.start)} - ${minutesToHHMM(entry.end)}`;
                            li.appendChild(textSpan);

                            const deleteButton = document.createElement('button');
                            deleteButton.textContent = 'Delete';
                            deleteButton.className = 'btn-delete-mini';
                            deleteButton.dataset.teacher = teacher;
                            deleteButton.dataset.start = entry.start;
                            deleteButton.dataset.end = entry.end;
                            deleteButton.dataset.date = dateKey;
                            li.appendChild(deleteButton);
                            
                            ul.appendChild(li);
                        });
                        groupDiv.appendChild(ul);
                        existingAbsencesList.appendChild(groupDiv);
                    }
                }
            }

            function populateStaffDropdown() {
                const sortedTeachers = [...allTeachers].sort();
                staffSelect.innerHTML = '<option value="">-- Select Staff --</option>';
                absenceStaffSelect.innerHTML = '<option value="">-- Select Staff --</option>';
                
                sortedTeachers.forEach(teacher => {
                    const option1 = document.createElement('option');
                    option1.value = teacher;
                    option1.textContent = teacher;
                    staffSelect.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = teacher;
                    option2.textContent = teacher;
                    absenceStaffSelect.appendChild(option2);
                });
            }

            function displayMonthlyTotals(year, monthIndex) {
                const data = getSavedMinutesData();
                const yearData = data[year] || {};
                const monthData = yearData[monthIndex] || {};
                
                const sortedTeachers = [...allTeachers].sort();
                
                if (sortedTeachers.length === 0) {
                     totalsDisplay.innerHTML = `<p class="status status-visible">No teachers loaded. Cannot display totals.</p>`;
                     return;
                }
                
                let hasData = false;
                for(const teacher of sortedTeachers) {
                    if (monthData[teacher] > 0) {
                        hasData = true;
                        break;
                    }
                }

                if (!hasData) {
                    totalsDisplay.innerHTML = `<p class="status status-visible">No data found for ${new Date(year, monthIndex).toLocaleString('default', { month: 'long' })} ${year}.</p>`;
                    return;
                }

                // Create table
                let tableHtml = '<table id="totals-table">';
                tableHtml += '<thead><tr><th>Teacher</th><th>Total Minutes</th><th>Total Hours</th></tr></thead>';
                tableHtml += '<tbody>';

                let grandTotalMinutes = 0;

                sortedTeachers.forEach(teacher => {
                    const totalMinutes = monthData[teacher] || 0;
                    if (totalMinutes > 0) { // Only show teachers with minutes
                        const totalHours = (totalMinutes / 60).toFixed(2);
                        tableHtml += `<tr>
                            <td>${teacher}</td>
                            <td>${totalMinutes}</td>
                            <td>${totalHours}</td>
                        </tr>`;
                        grandTotalMinutes += totalMinutes;
                    }
                });

                // Grand Total Row
                tableHtml += `<tr>
                    <td>Grand Total</td>
                    <td>${grandTotalMinutes}</td>
                    <td>${(grandTotalMinutes / 60).toFixed(2)}</td>
                </tr>`;

                tableHtml += '</tbody></table>';
                totalsDisplay.innerHTML = tableHtml;
            }
            
            function setupMonthButtons() {
                monthButtonsContainer.innerHTML = '';
                const year = parseInt(yearDisplay.value, 10);
                if (isNaN(year)) return;

                const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                
                months.forEach((month, index) => {
                    const button = document.createElement('button');
                    button.textContent = month;
                    button.dataset.month = index;
                    
                    button.addEventListener('click', () => {
                        const year = parseInt(yearDisplay.value, 10);
                        if (isNaN(year)) {
                            totalsDisplay.innerHTML = `<p class="status status-visible status-error">Please enter a valid year.</p>`;
                            return;
                        }
                        
                        if (activeMonthButton) {
                            activeMonthButton.classList.remove('active-month');
                        }
                        button.classList.add('active-month');
                        activeMonthButton = button;
                        
                        displayMonthlyTotals(year, index);
                    });
                    monthButtonsContainer.appendChild(button);
                });
            }

            function refreshAvailableNow() {
                try {
                    const now = new Date();
                    console.log("refreshAvailableNow: Refreshing at", now.toLocaleTimeString()); // Debug
                    const availability = getAvailabilityAtTime(now);
                    
                    if (availability && typeof availability === 'object') {
                        displayResults(availability.available, availability.onCallTimes, teachersNowList, statusNow, now);
                        lastUpdatedSpan.textContent = `Last updated: ${now.toLocaleTimeString()}`;
                    } else {
                        throw new Error("getAvailabilityAtTime returned invalid data.");
                    }
                } catch (error) {
                    console.error("Error in refreshAvailableNow:", error);
                    statusNow.textContent = `Error refreshing: ${error.message}`;
                    statusNow.className = 'status status-visible status-error';
                    lastUpdatedSpan.textContent = 'Last update failed.';
                }
            }

            function refreshAbsenceList() {
                const date = absenceDateInput.valueAsDate;
                if (date) {
                    // Adjust for timezone to get the correct YYYY-MM-DD key
                    const localDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000);
                    const dateKey = dateToYYYYMMDD(localDate);
                    displayExistingAbsences(dateKey);
                } else {
                    existingAbsencesList.innerHTML = `<p class="status status-visible">Select a date to see existing entries.</p>`;
                }
            }

            function applyFilter(inputId, listContainerId, itemSelectorType) {
                try {
                    const filterInput = document.getElementById(inputId);
                    const listContainer = document.getElementById(listContainerId);
                    if (!filterInput || !listContainer) return;
                    
                    const filterText = filterInput.value.toLowerCase().trim();
                    let items;

                    if (itemSelectorType === 'li') {
                        items = listContainer.getElementsByTagName('li');
                    } else if (itemSelectorType === 'group') {
                        items = listContainer.getElementsByClassName('absence-group');
                    } else {
                        return;
                    }

                    let visibleCount = 0;
                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];
                        let itemText;
                        
                        if (itemSelectorType === 'group') {
                            // Use the data attribute for filtering absence groups
                            itemText = item.dataset.teacherName || '';
                        } else {
                            itemText = item.textContent.toLowerCase();
                        }

                        if (itemText.includes(filterText)) {
                            item.classList.remove('filtered-hide');
                            visibleCount++;
                        } else {
                            item.classList.add('filtered-hide');
                        }
                    }
                } catch (e) {
                    console.error("Error applying filter:", e);
                }
            }


            // --- Initialization ---
            async function loadData() {
                console.log("loadData: Starting to load schedule..."); // Debug
                statusNow.textContent = 'Loading schedule...';
                statusNow.className = 'status status-visible'; // Reset styles
                lessons = [];
                allTeachers.clear();
                columnMap = {};

                try {
                    // Fetch the CSV with a cache-busting query parameter
                    const response = await fetch('schedule.csv?_=' + new Date().getTime(), {
                        cache: 'no-store' // Ask the browser not to cache the file
                    });
                    console.log("loadData: Fetch response status:", response.status); // Debug

                    if (!response.ok) {
                        // This catches errors like 404 Not Found
                        throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                    }

                    const csvText = await response.text();
                    if (!csvText || csvText.trim().length === 0) {
                        throw new Error("CSV file is empty.");
                    }
                    console.log("loadData: CSV text loaded, length:", csvText.length); // Debug

                    const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== '');

                    if (lines.length < 2) { // Need at least a header and one data row
                        throw new Error("CSV file must have a header and at least one data row.");
                    }

                    // Process Header
                    const headerLine = lines[0];
                    const header = parseCsvLine(headerLine).map(h => h.trim().toLowerCase());
                    header.forEach((col, index) => {
                        columnMap[col] = index;
                    });

                    // Check for required columns
                    const requiredCols = ['teacher', 'day', 'starttime', 'length', 'subject', 'realweeks'];
                    const missingCols = requiredCols.filter(col => typeof columnMap[col] === 'undefined');
                    if (missingCols.length > 0) {
                        throw new Error(`CSV is missing required headers: ${missingCols.join(', ')}`);
                    }
                    console.log("loadData: Column map created successfully:", columnMap); // Debug

                    // Process Data Rows
                    for (let i = 1; i < lines.length; i++) {
                        const values = parseCsvLine(lines[i]);
                        if (values.length >= header.length) {
                            const lessonData = {};
                            header.forEach((col, index) => {
                                lessonData[col] = values[index] || '';
                            });
                            lessons.push(lessonData);

                            // Populate allTeachers set
                            const teachersInLesson = parseTeachers(lessonData['teacher']);
                            teachersInLesson.forEach(teacher => {
                                if (teacher && !EXCLUDE_TEACHERS_SET.has(teacher)) {
                                    allTeachers.add(teacher);
                                }
                            });
                        }
                    }
                    console.log(`loadData: Processed ${lessons.length} lessons. Found ${allTeachers.size} unique teachers.`); // Debug

                    if (allTeachers.size === 0) {
                        console.warn("No teachers were found in the CSV (or all were excluded).");
                    }

                    // --- Success ---
                    // All data is loaded, now populate the UI
                    populateStaffDropdown();
                    setupMonthButtons();
                    refreshAvailableNow(); // This is what updates the "Loading..." status
                    refreshAbsenceList(); 
                    
                    if (refreshIntervalId) {
                        clearInterval(refreshIntervalId);
                    }
                    refreshIntervalId = setInterval(refreshAvailableNow, REFRESH_INTERVAL_MS);
                    console.log("loadData: Finished successfully. Refresh interval set."); // Debug

                } catch (error) {
                    // --- Failure ---
                    // This will catch any error from the 'try' block (fetch, parsing, etc.)
                    console.error('Error in loadData:', error); // Critical
                    statusNow.textContent = `Error: Could not load schedule. ${error.message}`;
                    statusNow.className = 'status status-visible status-error';
                    lastUpdatedSpan.textContent = 'Last attempt failed.';
                    teachersNowList.innerHTML = '';
                }
            }


            // --- Event Listeners --- 
            checkButton.addEventListener('click', () => {
                console.log("Check Availability button clicked."); // DEBUG
                try {
                    const date = dateInput.valueAsDate;
                    const timeFrom = timeFromInput.value;
                    const timeTo = timeToInput.value;

                    if (!date || !timeFrom || !timeTo) {
                        console.log("Check button validation failed: Missing date/time."); // DEBUG
                        statusCustom.textContent = 'Please select a date and a time range.';
                        statusCustom.className = 'status status-visible status-error';
                        teachersCustomList.innerHTML = '';
                        return;
                    }
                    
                    // Adjust for timezone issues with valueAsDate giving UTC date
                    const localDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000);

                    const startMinutes = timeToMinutes(timeFrom);
                    const endMinutes = timeToMinutes(timeTo);

                    if (startMinutes >= endMinutes) {
                        console.log("Check button validation failed: Start time >= End time."); // DEBUG
                        statusCustom.textContent = 'Invalid time: "From" time must be before "To" time.';
                        statusCustom.className = 'status status-visible status-error';
                        teachersCustomList.innerHTML = '';
                        return;
                    }
                    
                    statusCustom.textContent = `Checking for: ${localDate.toDateString()} from ${timeFrom} to ${timeTo}...`;
                    statusCustom.className = 'status status-visible'; // Reset to default
                    console.log(`Calling getAvailabilityForRange with date: ${localDate}, start: ${startMinutes}, end: ${endMinutes}`); // DEBUG

                    const availability = getAvailabilityForRange(localDate, startMinutes, endMinutes);
                    console.log("getAvailabilityForRange returned:", availability); // DEBUG

                    if (availability && typeof availability === 'object' && availability.hasOwnProperty('available') && availability.hasOwnProperty('onCallTimes')) {
                        displayResults(availability.available, availability.onCallTimes, teachersCustomList, statusCustom, localDate); 
                        console.log("displayResults called for custom list."); // DEBUG
                    } else {
                        console.error("ERROR: getAvailabilityForRange did not return the expected object. Returned:", availability);
                        statusCustom.textContent = `Internal error: Failed to get availability data structure. Check console.`;
                        statusCustom.className = 'status status-visible status-error'; 
                        teachersCustomList.innerHTML = ''; // Clear list on error
                    }

                } catch (e) {
                    console.error("Error in checkButton click:", e);
                    statusCustom.textContent = `An error occurred: ${e.message}`;
                    statusCustom.className = 'status status-visible status-error';
                }
            });

            saveMinutesButton.addEventListener('click', () => {
                const teacher = staffSelect.value;
                const date = dateEntryInput.value;
                const minutes = parseInt(minutesInput.value, 10);

                if (!teacher || !date || isNaN(minutes) || minutes <= 0) {
                    showSaveStatus('Please select a staff member, a valid date, and enter a positive number of minutes.', true);
                    return;
                }

                const dateObj = new Date(date);
                // Adjust for timezone offset
                const localDate = new Date(dateObj.getTime() + dateObj.getTimezoneOffset() * 60000);
                const year = localDate.getFullYear();
                const month = localDate.getMonth(); // 0-11
                
                const data = getSavedMinutesData();
                
                if (!data[year]) data[year] = {};
                if (!data[year][month]) data[year][month] = {};
                if (!data[year][month][teacher]) data[year][month][teacher] = 0;
                
                data[year][month][teacher] += minutes;
                
                saveMinutesData(data);
                
                showSaveStatus(`Saved ${minutes} minutes for ${teacher} on ${date}.`, false);
                
                // Clear inputs
                staffSelect.value = '';
                dateEntryInput.value = '';
                minutesInput.value = '';

                // Refresh totals view if it's the one being modified
                if (activeMonthButton && parseInt(activeMonthButton.dataset.month, 10) === month && parseInt(yearDisplay.value, 10) === year) {
                    displayMonthlyTotals(year, month);
                }
            });

            exportSummaryButton.addEventListener('click', () => {
                const year = parseInt(yearDisplay.value, 10);
                if (isNaN(year)) {
                    showImportStatus('Please enter a valid year to export.', true); // Re-using import status for feedback
                    return;
                }

                const data = getSavedMinutesData();
                const yearData = data[year] || {};
                const sortedTeachers = [...allTeachers].sort();
                const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                
                let csvContent = "data:text/csv;charset=utf-8,";
                // Header
                csvContent += `Teacher,${months.join(',')},Year Total (Min),Year Total (Hours)\r\n`;

                // Rows
                sortedTeachers.forEach(teacher => {
                    let row = [`"${teacher}"`]; // Quote teacher name
                    let yearTotalMinutes = 0;
                    for (let i = 0; i < 12; i++) {
                        const monthData = yearData[i] || {};
                        const minutes = monthData[teacher] || 0;
                        row.push(minutes);
                        yearTotalMinutes += minutes;
                    }
                    row.push(yearTotalMinutes);
                    row.push((yearTotalMinutes / 60).toFixed(2));
                    
                    if (yearTotalMinutes > 0) { // Only export teachers with data
                        csvContent += row.join(',') + '\r\n';
                    }
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `extra_minutes_summary_${year}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            exportBackupButton.addEventListener('click', () => {
                const data = getSavedMinutesData();
                if (Object.keys(data).length === 0) {
                    showImportStatus('No data to export.', true);
                    return;
                }

                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "year,month_index,teacher,minutes\r\n"; // Header
                
                // Rows
                for (const year in data) {
                    for (const month in data[year]) {
                        for (const teacher in data[year][month]) {
                            const minutes = data[year][month][teacher];
                            csvContent += `${year},${month},"${teacher}",${minutes}\r\n`;
                        }
                    }
                }

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `extra_minutes_backup_${dateToYYYYMMDD(new Date())}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            clearDataButton.addEventListener('click', () => {
                const userConfirmed = confirm("Are you sure you want to delete ALL saved extra minutes data? This cannot be undone.");
                
                if (userConfirmed) {
                    try {
                        localStorage.removeItem(MINUTES_STORAGE_KEY);
                        showImportStatus('All extra minutes data has been cleared.', false);
                        // Reset views
                        totalsDisplay.innerHTML = `<p class="status status-visible">Select a month to see totals.</p>`;
                        if (activeMonthButton) {
                            activeMonthButton.classList.remove('active-month');
                            activeMonthButton = null;
                        }
                    } catch (e) {
                        showImportStatus(`Error clearing data: ${e.message}`, true);
                    }
                } else {
                    showImportStatus('Clear data operation cancelled.', false);
                }
            });

            importCsvButton.addEventListener('click', () => { 
                csvFileInput.value = null; // Reset file input
                csvFileInput.click(); 
            });

            csvFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showImportStatus('No file selected.', true);
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');
                        
                        if (lines.length < 2) {
                            throw new Error("CSV file must have a header and at least one data row.");
                        }

                        // Use parseCsvLine for the header to handle potential quotes
                        const header = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());
                        const requiredCols = ['year', 'month_index', 'teacher', 'minutes'];
                        const missingCols = requiredCols.filter(col => !header.includes(col));
                        if (missingCols.length > 0) {
                            throw new Error(`Invalid CSV format. Missing columns: ${missingCols.join(', ')}`);
                        }
                        
                        const colMap = {};
                        header.forEach((col, index) => { colMap[col] = index; });

                        const importedData = getSavedMinutesData();
                        let entriesProcessed = 0;

                        for (let i = 1; i < lines.length; i++) {
                            // Use parseCsvLine for each data row
                            const values = parseCsvLine(lines[i]);
                            if (values.length < requiredCols.length) continue; // Skip empty/malformed lines
                            
                            const year = values[colMap['year']];
                            const month = values[colMap['month_index']];
                            const teacher = values[colMap['teacher']]; // Already unquoted by parseCsvLine
                            const minutes = parseInt(values[colMap['minutes']], 10);

                            if (year && month && teacher && !isNaN(minutes) && minutes > 0) {
                                if (!importedData[year]) importedData[year] = {};
                                if (!importedData[year][month]) importedData[year][month] = {};
                                if (!importedData[year][month][teacher]) importedData[year][month][teacher] = 0;
                                
                                importedData[year][month][teacher] += minutes; // Add to existing
                                entriesProcessed++;
                            }
                        }

                        saveMinutesData(importedData);
                        showImportStatus(`Successfully imported and merged ${entriesProcessed} entries.`, false);
                        
                        // Refresh view
                        if (activeMonthButton) {
                            const year = parseInt(yearDisplay.value, 10);
                            const month = parseInt(activeMonthButton.dataset.month, 10);
                            displayMonthlyTotals(year, month);
                        }

                    } catch (error) {
                        showImportStatus(`Error importing file: ${error.message}`, true);
                    }
                };
                reader.readAsText(file);
            });
            
            // --- Absence Listeners ---
            saveAbsenceButton.addEventListener('click', () => {
                const teacher = absenceStaffSelect.value;
                const date = absenceDateInput.valueAsDate;
                const timeFrom = absenceTimeFromInput.value;
                const timeTo = absenceTimeToInput.value;

                if (!teacher || !date || !timeFrom || !timeTo) {
                    showAbsenceSaveStatus('Please select a staff member, date, and time range.', true);
                    return;
                }
                
                // Adjust for timezone to get the correct YYYY-MM-DD key
                const localDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000);
                const dateKey = dateToYYYYMMDD(localDate);
                
                const startMinutes = timeToMinutes(timeFrom);
                const endMinutes = timeToMinutes(timeTo);

                if (startMinutes >= endMinutes) {
                    showAbsenceSaveStatus('Invalid time: "From" time must be before "To" time.', true);
                    return;
                }
                
                const absenceData = getSavedAbsenceData();
                if (!absenceData[dateKey]) absenceData[dateKey] = {};
                if (!absenceData[dateKey][teacher]) absenceData[dateKey][teacher] = [];
                
                // Check for duplicates
                const exists = absenceData[dateKey][teacher].some(entry => entry.start === startMinutes && entry.end === endMinutes);
                
                if (exists) {
                    showAbsenceSaveStatus('This exact absence entry already exists.', true);
                    return;
                }

                absenceData[dateKey][teacher].push({ start: startMinutes, end: endMinutes });
                // Sort entries by start time
                absenceData[dateKey][teacher].sort((a, b) => a.start - b.start);
                
                saveAbsenceData(absenceData);
                showAbsenceSaveStatus(`Saved absence for ${teacher} on ${dateKey}.`, false);
                
                // Clear inputs
                absenceStaffSelect.value = '';
                // Keep date, clear times
                absenceTimeFromInput.value = '';
                absenceTimeToInput.value = '';

                // Refresh the list
                displayExistingAbsences(dateKey);
                // Refresh the "Available Now" list to show absence status
                refreshAvailableNow();
            });

            absenceDateInput.addEventListener('change', refreshAbsenceList);

            existingAbsencesList.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.teacher) {
                    const { teacher, start, end, date } = e.target.dataset;
                    
                    if (confirm(`Delete absence for ${teacher} (${minutesToHHMM(start)} - ${minutesToHHMM(end)}) on ${date}?`)) {
                        const startMin = parseInt(start, 10);
                        const endMin = parseInt(end, 10);
                        
                        const absenceData = getSavedAbsenceData();
                        if (absenceData[date] && absenceData[date][teacher]) {
                            // Filter out the entry to be deleted
                            absenceData[date][teacher] = absenceData[date][teacher].filter(entry => 
                                !(entry.start === startMin && entry.end === endMin)
                            );
                            
                            // If no entries left for teacher, remove teacher
                            if (absenceData[date][teacher].length === 0) {
                                delete absenceData[date][teacher];
                            }
                            // If no teachers left for date, remove date
                            if (Object.keys(absenceData[date]).length === 0) {
                                delete absenceData[date];
                            }
                            
                            saveAbsenceData(absenceData);
                            showAbsenceSaveStatus('Absence deleted.', false);
                            
                            // Refresh the list
                            displayExistingAbsences(date);
                            // Refresh the "Available Now" list
                            refreshAvailableNow();
                        }
                    }
                }
            });

            exportAbsencesButton.addEventListener('click', () => {
                const data = getSavedAbsenceData();
                if (Object.keys(data).length === 0) {
                    showAbsenceImportStatus('No absence data to export.', true);
                    return;
                }

                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "date,teacher,time_from,time_to\r\n"; // Header
                
                // Rows
                const sortedDates = Object.keys(data).sort(); // Sort by date
                for (const date of sortedDates) {
                    const sortedTeachers = Object.keys(data[date]).sort(); // Then sort by teacher
                    for (const teacher of sortedTeachers) {
                        for (const entry of data[date][teacher]) {
                            const timeFrom = minutesToHHMM(entry.start);
                            const timeTo = minutesToHHMM(entry.end);
                            csvContent += `${date},"${teacher}",${timeFrom},${timeTo}\r\n`;
                        }
                    }
                }

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `teacher_absences_backup_${dateToYYYYMMDD(new Date())}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            importAbsencesButton.addEventListener('click', () => { 
                absenceCsvFileInput.value = null; // Reset file input
                absenceCsvFileInput.click(); 
            });

            absenceCsvFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showAbsenceImportStatus('No file selected.', true);
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');
                        
                        if (lines.length < 2) {
                            throw new Error("CSV file must have a header and at least one data row.");
                        }

                        const header = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());
                        const requiredCols = ['date', 'teacher', 'time_from', 'time_to'];
                        const missingCols = requiredCols.filter(col => !header.includes(col));
                        if (missingCols.length > 0) {
                            throw new Error(`Invalid CSV format. Missing columns: ${missingCols.join(', ')}`);
                        }
                        
                        const colMap = {};
                        header.forEach((col, index) => { colMap[col] = index; });

                        const importedData = getSavedAbsenceData();
                        let entriesProcessed = 0;

                        for (let i = 1; i < lines.length; i++) {
                            const values = parseCsvLine(lines[i]);
                            if (values.length < requiredCols.length) continue; // Skip malformed lines

                            const dateKey = values[colMap['date']].trim();
                            const teacher = values[colMap['teacher']].trim(); // Already unquoted
                            const timeFrom = values[colMap['time_from']].trim();
                            const timeTo = values[colMap['time_to']].trim();
                            
                            const startMinutes = timeToMinutes(timeFrom);
                            const endMinutes = timeToMinutes(timeTo);

                            if (dateKey && teacher && !isNaN(startMinutes) && !isNaN(endMinutes) && startMinutes < endMinutes) {
                                if (!importedData[dateKey]) importedData[dateKey] = {};
                                if (!importedData[dateKey][teacher]) importedData[dateKey][teacher] = [];

                                // Check for duplicates before adding
                                const exists = importedData[dateKey][teacher].some(entry => entry.start === startMinutes && entry.end === endMinutes);
                                if (!exists) {
                                    importedData[dateKey][teacher].push({ start: startMinutes, end: endMinutes });
                                    // Sort entries by start time
                                    importedData[dateKey][teacher].sort((a, b) => a.start - b.start);
                                    entriesProcessed++;
                                }
                            }
                        }

                        saveAbsenceData(importedData);
                        showAbsenceImportStatus(`Successfully imported and merged ${entriesProcessed} absence entries.`, false);
                        
                        // Refresh views
                        refreshAbsenceList();
                        refreshAvailableNow();

                    } catch (error) {
                        showAbsenceImportStatus(`Error importing file: ${error.message}`, true);
                    }
                };
                reader.readAsText(file);
            });

            // --- Filter Event Listeners ---
            filterNowInput.addEventListener('input', () => applyFilter('filter-now', 'teachers-now', 'li'));
            filterCustomInput.addEventListener('input', () => applyFilter('filter-custom', 'teachers-custom', 'li'));
            filterAbsencesInput.addEventListener('input', () => applyFilter('filter-absences', 'existing-absences-list', 'group'));

            // --- Start the application ---
            loadData();

        });
    </script>
</body>
</html>

