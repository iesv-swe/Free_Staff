<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Availability</title>
    <style>
        /* Base Dark Theme */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background-color: #102d69; /* Navy Blue background */
            color: #dbdad8; /* Light Grey text */
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
        }

        .logo {
            width: 180px;
            height: auto;
            margin-bottom: 10px;
            /* Optional: Add filter if logo looks better inverted on dark bg */
            /* filter: invert(1) hue-rotate(180deg); */
        }

        h1, h2 {
            border-bottom: 2px solid #00a0df; /* IES Logo Blue border */
            padding-bottom: 10px;
            color: #ffffff; /* White headings */
        }

        /* Container Styling */
        .container {
            background-color: #1a3a7f; /* Derived darker blue */
            border: 1px solid #9a9b9d; /* IES Logo Grey border */
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
            color: #dbdad8; /* Ensure text inside container is light */
        }

        /* Input Fields */
        .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .input-group { margin-bottom: 15px; }
        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #ffffff; /* White labels */
        }
        .input-group input, .input-group select {
            width: 95%;
            padding: 8px 12px;
            border: 1px solid #9a9b9d; /* IES Logo Grey border */
            border-radius: 6px;
            background-color: #2a4a8f; /* Darker input background */
            color: #ffffff; /* White text in inputs */
        }
        .input-group input::placeholder {
             color: #9a9b9d;
        }

        /* Buttons */
        button {
            /* Default button: IES Logo Blue */
            background-color: #00a0df;
            color: #ffffff;
            font-weight: 600;
            padding: 10px 16px;
            border: 1px solid #007ead; /* Darker blue border */
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #007ead; /* Darker blue on hover */
            border-color: #005c8a;
        }

        /* Reusable Green Button Style */
        button.btn-green {
            background-color: #2ea44f; /* Green */
            border-color: #2c974b;
            color: #ffffff; /* Ensure white text */
        }
        button.btn-green:hover {
            background-color: #2c974b; /* Darker green */
            border-color: #258141;
        }

        /* Secondary Button: IES Logo Grey */
        button.secondary {
            background-color: #9a9b9d;
            color: #102d69; /* Navy text for contrast */
            border-color: #7a7b7d;
        }
        button.secondary:hover {
            background-color: #7a7b7d;
            border-color: #5a5b5d;
        }

        /* Danger Button: Keep Red */
        button.danger {
            background-color: #d73a49;
            color: #ffffff;
            border-color: rgba(27, 31, 35, 0.15);
        }
        button.danger:hover { background-color: #cb2431; }

        /* Purple Button Style (Used for primary & summary) */
        button.primary {
            background-color: #6f42c1;
            color: #ffffff;
            border-color: #5833a6;
        }
        button.primary:hover {
             background-color: #5833a6;
             border-color: #442681;
        }

        /* Info Button Style (Keep as IES Blue if needed elsewhere, not used by Summary anymore) */
         button.info {
            background-color: #00a0df;
            color: #ffffff;
            border-color: #007ead;
        }
        button.info:hover {
             background-color: #007ead;
             border-color: #005c8a;
        }

        .button-group { display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; margin-top: 15px; }
        .absence-button-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

        /* Results & Status */
        .results { margin-top: 20px; }
        .status {
            font-style: italic;
            color: #9a9b9d; /* IES Logo Grey for default status */
        }
        .status.error { color: #d73a49; font-weight: 600; } /* Keep Red */
        .status.success { color: #2ea44f; font-weight: 600; } /* Keep Green */

        /* Teacher List Items */
        .teacher-list { display: flex; flex-wrap: wrap; gap: 8px; list-style: none; padding: 0; }
        .teacher-list li {
            background-color: #2a4a8f; /* Dark background */
            border: 1px solid #9a9b9d; /* IES Logo Grey border */
            color: #dbdad8; /* Light Grey text */
            border-radius: 10px;
            padding: 5px 12px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        .teacher-list li.on-call {
            background-color: #2ea44f; /* Green */
            color: #ffffff; /* White text */
            border-color: #2c974b; /* Darker green border */
            font-weight: 600;
        }

        /* Keep warning colors */
        .teacher-list li.minutes-danger { background-color: #d73a49; color: #ffffff; border: 1px solid #cb2431; font-weight: 600; }
        .teacher-list li.minutes-warn { background-color: #ffc107; border: 1px solid #e0a800; color: #102d69; } /* Dark text on yellow */

        /* Month Buttons */
        .month-buttons { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 15px; }
        .month-buttons button {
            background-color: #9a9b9d;
            color: #102d69;
            border-color: #7a7b7d;
            flex-grow: 1;
            margin-top: 0;
            padding: 5px 8px;
            font-weight: normal;
        }
         .month-buttons button:hover {
            background-color: #7a7b7d;
            border-color: #5a5b5d;
         }
        .month-buttons button.active {
            background-color: #00a0df; /* IES Blue */
            color: #ffffff;
            border-color: #007ead;
            font-weight: 600;
        }

        /* Totals Display */
        #totals-display {
            background-color: #1a3a7f;
            border: 1px solid #9a9b9d;
            border-radius: 6px;
            padding: 15px;
            min-height: 50px;
            color: #dbdad8;
        }
        #totals-display h3 { margin-top: 0; color: #ffffff; }
        #totals-display li {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            list-style: none;
            padding: 4px 8px; margin: 2px 0;
            border-radius: 4px;
            background-color: #2a4a8f;
            border: 1px solid #9a9b9d;
         }
        #totals-display li.minutes-danger { background-color: #d73a49; color: #ffffff; border: 1px solid #cb2431; font-weight: 600; }
        #totals-display li.minutes-warn { background-color: #ffc107; border: 1px solid #e0a800; color: #102d69; }

        #csv-file-input, #absence-csv-file-input { display: none; }

        /* Absence List Specifics */
        #existing-absences-list h4 {
            margin-bottom: 5px;
            margin-top: 15px;
            border-bottom: 1px dashed #9a9b9d;
            padding-bottom: 3px;
            color: #bce4fa; /* Light Blue */
         }
        #existing-absences-list ul { padding-left: 0; margin-top: 5px;}
        #existing-absences-list li {
             margin-bottom: 10px;
             list-style-type: none;
             border-bottom: 1px solid #4a6aab; /* Darker separator */
             padding-bottom: 10px;
         }
         #existing-absences-list li strong {
             color: #ffffff; /* White time */
         }
    </style>
</head>
<body>

    <img src="logo.png" alt="Logo" class="logo">
    <h1>Teacher Availability</h1>

    <div class="container">
        <h2>Available Right Now</h2>
        <div id="status-now" class="status">Loading schedule...</div>
        <div id="results-now" class="results"><ul id="teachers-now" class="teacher-list"></ul></div>
    </div>
    <div class="container">
        <h2>Check Availability for a Time Range</h2>
        <div class="input-group"><label for="date-input">Date:</label><input type="date" id="date-input"></div>
        <div class="input-grid">
            <div class="input-group"><label for="time-from-input">Time (From):</label><input type="time" id="time-from-input"></div>
            <div class="input-group"><label for="time-to-input">Time (To):</label><input type="time" id="time-to-input"></div>
        </div>
        <button id="check-button" class="btn-green">Check Availability</button> <div id="status-custom" class="status" style="display:none;"></div>
        <div id="results-custom" class="results"><ul id="teachers-custom" class="teacher-list"></ul></div>
    </div>

    <div class="container">
        <h2>Log Staff Absence (Training, Meetings, etc.)</h2>
        <p>Log a time range when a staff member is unavailable. This will remove them from the availability lists for that specific time.</p>
        <div class="input-grid">
            <div class="input-group">
                <label for="absence-staff-select">Staff Member:</label>
                <select id="absence-staff-select"><option value="">-- Select Staff --</option></select>
            </div>
            <div class="input-group">
                <label for="absence-date-input">Date of Absence:</label>
                <input type="date" id="absence-date-input">
            </div>
        </div>
        <div class="input-grid">
            <div class="input-group">
                <label for="absence-time-from-input">Time (From):</label>
                <input type="time" id="absence-time-from-input">
            </div>
            <div class="input-group">
                <label for="absence-time-to-input">Time (To):</label>
                <input type="time" id="absence-time-to-input">
            </div>
        </div>
        <button id="save-absence-button" class="btn-green">Save</button>
        <div id="absence-save-status" class="status" style="display:none; margin-top:10px;"></div>

        <h3 style="margin-top: 20px; border-top: 1px solid #00a0df; padding-top: 15px;">Existing Absences for Selected Day</h3>
        <div id="existing-absences-list" style="padding-left: 0;">
            <p class="status">Select a date to see existing entries.</p>
        </div>

        <div class="absence-button-group">
             <button id="export-absences-button" class="btn-green">Export Absences CSV</button>
             <button id="import-absences-button" class="secondary">Import Absences CSV</button>
             <input type="file" id="absence-csv-file-input" accept=".csv">
        </div>
         <div id="absence-import-status" class="status" style="display:none; margin-top:10px;"></div>

    </div>

    <div class="container">
        <h2>Traking Substitution</h2> <p>Record extra minutes worked by staff. This data is saved in your browser.</p>
        <div class="input-grid">
            <div class="input-group"><label for="staff-select">Staff Member:</label><select id="staff-select"><option value="">-- Select Staff --</option></select></div>
            <div class="input-group"><label for="date-entry-input">Date Worked:</label><input type="date" id="date-entry-input"></div>
        </div>
        <div class="input-group"><label for="minutes-input">Add Extra Minutes:</label><input type="number" id="minutes-input" placeholder="e.g., 60"></div>
        <button id="save-minutes-button" class="btn-green">Save Minutes</button>
        <div id="save-status" class="status" style="display:none; margin-top:10px;"></div>
    </div>

    <div class="container">
        <h2>Traking Substitution - Totals</h2> <div class="input-group"><label for="year-display">Select Year:</label><input type="number" id="year-display" value="2025"></div>
        <div class="month-buttons" id="month-buttons"></div>
        <div id="totals-display"><p>Select a month to see totals.</p></div>
        <div class="button-group">
            <button id="export-backup-button" class="btn-green">Export CSV (Entries)</button> <!-- Changed label -->
            <button id="export-summary-button" class="primary">Summary CSV (Totals)</button> <!-- Changed label -->
            <button id="import-csv-button" class="secondary">Import CSV (Entries)</button> <!-- Changed label -->
            <input type="file" id="csv-file-input" accept=".csv">
            <button id="clear-data-button" class="danger">Clear All Saved Data</button>
        </div>
        <div id="import-status" class="status" style="display:none; margin-top:10px;"></div>
    </div>


    <!-- 
    ============================================================================
    === REFACTORED JAVASCRIPT BLOCK ============================================
    ============================================================================
    All JavaScript logic is contained within this single <script> tag.
    It is organized into 9 sections for readability and maintainability:
    
    1. CONFIGURATION
    2. APPLICATION STATE & DOM ELEMENTS
    3. STORAGE HELPERS
    4. UTILITY FUNCTIONS
    5. CORE AVAILABILITY LOGIC
    6. UI/DISPLAY FUNCTIONS
    7. EVENT HANDLERS
    8. INITIALIZATION & MIGRATION
    9. APPLICATION START
    
    ============================================================================
    -->
    <script>
        // --- 1. CONFIGURATION ---
        // Static config values for the application
        const ARBETSTID_SUBJECT = "arbetstid";
        const ON_CALL_SUBJECT = "on call substitution";
        const EXCLUDE_TEACHER_LIST = ["BaSh", "AnHo", "DaWr", "AniFac", "RahHan", "ChBe", "FaCa", "SeCa", "AlCh", "LaCo", "VikCos", "RoDi", "KrEr", "RaHa", "JeHe", "DiHe", "GaHe", "HeKa", "JoLe", "TiLe", "WiLi", "ChLi", "HaLu", "KaMa", "ViMe", "MaMe", "HiOj", "LePa", "AsRo", "RaSc", "TaSc", "JeSe", "AnVa", "MarMen", "JonLeh"];
        const EXCLUDE_TEACHERS_SET = new Set(EXCLUDE_TEACHER_LIST);
        const MINUTES_STORAGE_KEY = 'teacherMinutesData_v2'; // Changed key to avoid conflict with old format during migration
        const OLD_MINUTES_STORAGE_KEY = 'teacherMinutesData'; // Key for the old format
        const ABSENCE_STORAGE_KEY = 'teacherAbsenceData'; // Absence format remains the same
        const DAY_MAP = ["Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat"];

        // --- 2. APPLICATION STATE & DOM ELEMENTS ---
        // These variables hold the application's state and DOM element references.
        // They are declared here and assigned inside DOMContentLoaded.
        let lessons = [];
        let allTeachers = new Set();
        let columnMap = {};
        let activeMonthButton = null;

        // DOM Element Placeholders
        let statusNow, teachersNowList, statusCustom, teachersCustomList, checkButton,
            dateInput, timeFromInput, timeToInput, staffSelect, dateEntryInput,
            minutesInput, saveMinutesButton, saveStatus, yearDisplay,
            monthButtonsContainer, totalsDisplay, exportSummaryButton,
            exportBackupButton, clearDataButton, importCsvButton, csvFileInput,
            importStatus, absenceStaffSelect, absenceDateInput, absenceTimeFromInput,
            absenceTimeToInput, saveAbsenceButton, absenceSaveStatus,
            existingAbsencesList, exportAbsencesButton, importAbsencesButton,
            absenceCsvFileInput, absenceImportStatus;

        // --- 3. STORAGE HELPERS ---
        // Reusable functions for reading from and writing to localStorage.

        /**
         * Gets and parses JSON data from localStorage.
         * @param {string} key The localStorage key to retrieve.
         * @returns {object} The parsed data or a new empty object if not found/invalid.
         */
        function getStorageData(key) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : {};
            } catch (error) {
                console.error(`Error reading ${key} from localStorage:`, error);
                return {};
            }
        }

        /**
         * Saves MINUTE data (new format) to localStorage.
         * @param {object} data The minutes data object (new format) to save.
         */
        function saveMinutesData(data) {
            try {
                localStorage.setItem(MINUTES_STORAGE_KEY, JSON.stringify(data));
            } catch (error) {
                console.error("Error saving minutes data to localStorage:", error);
                showSaveStatus("Critical error saving data. Check console.", true);
            }
        }

        /**
         * Saves ABSENCE data to localStorage.
         * @param {object} data The absence data object to save.
         */
        function saveAbsenceData(data) {
            try {
                localStorage.setItem(ABSENCE_STORAGE_KEY, JSON.stringify(data));
            } catch (error) {
                console.error("Error saving absence data to localStorage:", error);
                if (absenceSaveStatus) {
                    showAbsenceSaveStatus("Critical error saving data. Check console.", true);
                }
            }
        }

        // --- 4. UTILITY FUNCTIONS ---
        // General-purpose helper functions.

        /**
         * Calculates the ISO week number and year for a given date.
         * @param {Date} d The input date object.
         * @returns {{week: number, year: number, weekKey: string}}
         */
        function getIsoWeekAndYear(d) {
            const defaultWeek = { week: 0, year: 0, weekKey: '0000-W00' };
            try {
                if (!(d instanceof Date) || isNaN(d.getTime())) { console.error("getIsoWeekAndYear received invalid date:", d); return defaultWeek; }
                const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                const dayOfWeek = date.getUTCDay();
                date.setUTCDate(date.getUTCDate() + 4 - (dayOfWeek || 7));
                const year = date.getUTCFullYear();
                const yearStart = new Date(Date.UTC(year, 0, 1));
                const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
                if (isNaN(weekNo) || isNaN(year)) { console.error("getIsoWeekAndYear calculation resulted in NaN:", { date: d, weekNo, year }); return defaultWeek; }
                return { week: weekNo, year: year, weekKey: `${year}-W${String(weekNo).padStart(2, '0')}` };
            } catch (error) { console.error("Critical error inside getIsoWeekAndYear:", error, "Input date:", d); return defaultWeek; }
        }

        /**
         * Converts a time string (e.g., "09:00" or "900") to total minutes from midnight.
         * @param {string} timeStr The time string.
         * @returns {number} Total minutes from midnight, or 0 if invalid.
         */
        function timeToMinutes(timeStr) {
            if (!timeStr) return 0; // Original returns 0
            timeStr = timeStr.replace(':', '');
            if (timeStr.length < 4) timeStr = '0' + timeStr;
            const hours = parseInt(timeStr.substring(0, 2), 10);
            const minutes = parseInt(timeStr.substring(2, 4), 10);
            return (isNaN(hours) || isNaN(minutes)) ? 0 : (hours * 60) + minutes; // Original returns 0
        }

        /**
         * Converts total minutes to an "HH:MM" formatted string.
         * @param {number} totalMinutes The number of minutes.
         * @returns {string} The "HH:MM" formatted string.
         */
        function minutesToHHMM(totalMinutes) {
            if (isNaN(totalMinutes) || totalMinutes < 0) return "00:00";
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes) % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        /**
         * Parses a comma-separated week string (e.g., "35-39, 41") into a Set.
         * @param {string} weekString The week string from the schedule.
         * @returns {Set<number>} A Set containing all valid week numbers.
         */
        function parseRealWeeks(weekString) {
            const weeks = new Set(); if (!weekString) return weeks; weekString.split(',').forEach(range => { const parts = range.trim().split('-'); if (parts.length === 1 && parts[0]) { const weekNum = parseInt(parts[0], 10); if (!isNaN(weekNum)) weeks.add(weekNum); } else if (parts.length === 2 && parts[0] && parts[1]) { try { const start = parseInt(parts[0], 10); const end = parseInt(parts[1], 10); if (!isNaN(start) && !isNaN(end) && start <= end) { for (let i = start; i <= end; i++) { weeks.add(i); } } } catch (e) { console.error("Error parsing week range:", range, e); } } }); return weeks;
        }

        /**
         * Parses a comma-separated teacher string (handling quotes) into an array.
         * @param {string} teacherString The teacher string from the schedule.
         * @returns {string[]} An array of teacher names.
         */
        function parseTeachers(teacherString) {
            try {
                if (teacherString && teacherString.startsWith('"') && teacherString.endsWith('"')) {
                    teacherString = teacherString.substring(1, teacherString.length - 1).replace(/""/g, '"');
                }
                if (!teacherString || typeof teacherString !== 'string') return [];
                const teachers = teacherString.split(',').map(t => t.trim()).filter(t => t && t.length > 0);
                return Array.isArray(teachers) ? teachers : [];
            } catch (error) { console.error("Error inside parseTeachers:", error, "Input:", teacherString); return []; }
        }

        /**
         * A simple, robust CSV line parser that handles quoted fields and custom delimiters.
         * @param {string} line A single line from a CSV file.
         * @param {string} [delimiter=','] The delimiter character (',' or ';'). Defaults to ','.
         * @returns {string[]} An array of field values.
         */
        function parseCsvLine(line, delimiter = ',') { // Added delimiter parameter
            const result = [];
            let currentField = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') { // Handle escaped quotes ""
                        currentField += '"';
                        i++; // Skip the second quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === delimiter && !inQuotes) { // Use the specified delimiter
                    result.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField.trim()); // Add the last field
            return result;
        }

        /**
         * Formats a timestamp (milliseconds since epoch) into a readable string.
         * Returns an empty string if the timestamp is invalid.
         * @param {number} timestamp Milliseconds since epoch.
         * @returns {string} Formatted date/time string (e.g., "2025-10-29 18:30:05") or "".
         */
        function formatTimestamp(timestamp) {
            if (typeof timestamp !== 'number' || isNaN(timestamp)) {
                return ""; // Return empty for invalid timestamps
            }
            try {
                const date = new Date(timestamp);
                return date.toLocaleString('sv-SE'); // Use Swedish locale for YYYY-MM-DD HH:MM:SS format
            } catch (e) {
                console.error("Error formatting timestamp:", timestamp, e);
                return ""; // Return empty on formatting error
            }
        }

        // --- 5. CORE AVAILABILITY LOGIC ---
        // The "brains" of the application. These functions calculate availability
        // based on the loaded lessons and stored absence data.

        /**
         * Checks if a teacher is absent at a specific point in time.
         * @param {string} teacher The teacher's name.
         * @param {Date} checkDate The date to check.
         * @param {number} checkTimeInMinutes The time to check (in minutes).
         * @returns {boolean} True if the teacher is absent.
         */
        function isTeacherAbsent(teacher, checkDate, checkTimeInMinutes) {
            const allData = getStorageData(ABSENCE_STORAGE_KEY);
            let dateKey = '';
            if (checkDate instanceof Date && !isNaN(checkDate)) {
                // Use ISO format (YYYY-MM-DD) for a reliable key
                const year = checkDate.getFullYear();
                const month = String(checkDate.getMonth() + 1).padStart(2, '0');
                const day = String(checkDate.getDate()).padStart(2, '0');
                dateKey = `${year}-${month}-${day}`;
            } else {
                console.warn("isTeacherAbsent received invalid date object:", checkDate);
                return false;
            }
            const dayEntries = allData[teacher]?.[dateKey] || [];
            if (dayEntries.length === 0) return false;
            for (const entry of dayEntries) {
                if (typeof entry.start === 'number' && typeof entry.end === 'number' && entry.start < entry.end) {
                    if (checkTimeInMinutes >= entry.start && checkTimeInMinutes < entry.end) {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Checks if a teacher has any absence that *overlaps* with a given time range.
         * @param {string} teacher The teacher's name.
         * @param {Date} checkDate The date to check.
         * @param {number} queryStart The start of the range (in minutes).
         * @param {number} queryEnd The end of the range (in minutes).
         * @returns {boolean} True if an absence overlaps with the range.
         */
        function isTeacherAbsentForRange(teacher, checkDate, queryStart, queryEnd) {
            const allData = getStorageData(ABSENCE_STORAGE_KEY);
            let dateKey = '';
            if (checkDate instanceof Date && !isNaN(checkDate)) {
                const year = checkDate.getFullYear();
                const month = String(checkDate.getMonth() + 1).padStart(2, '0');
                const day = String(checkDate.getDate()).padStart(2, '0');
                dateKey = `${year}-${month}-${day}`;
            } else {
                console.warn("isTeacherAbsentForRange received invalid date object:", checkDate);
                return false;
            }
            const dayEntries = allData[teacher]?.[dateKey] || [];
            if (dayEntries.length === 0) return false;
            for (const entry of dayEntries) {
                if (typeof entry.start === 'number' && typeof entry.end === 'number' && entry.start < entry.end) {
                    // Check for overlap: (AbsenceStart < QueryEnd) AND (AbsenceEnd > QueryStart)
                    if (entry.start < queryEnd && entry.end > queryStart) {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Finds available teachers at a *specific moment in time*.
         * @param {Date} dateTime The specific date and time to check.
         * @returns {{available: string[], onCallTimes: Map<string, {start: number, end: number}>}}
         */
        function getAvailabilityAtTime(dateTime) {
            const defaultResult = { available: [], onCallTimes: new Map() };
            try {
                if (!Array.isArray(lessons) || lessons.length === 0) { console.log("getAvailabilityAtTime: No lessons data."); return defaultResult; }
                const workingTeachers = new Set(); const onCallTimesMap = new Map(); const busyTeachers = new Set();
                const weekInfo = getIsoWeekAndYear(dateTime); if (!weekInfo) { console.error("getIsoWeekAndYear failed in getAvailabilityAtTime"); return defaultResult; } const { week: checkWeekNum, year: checkWeekYear } = weekInfo;
                const checkDay = DAY_MAP[dateTime.getDay()]; const checkTimeInMinutes = (dateTime.getHours() * 60) + dateTime.getMinutes();
                lessons.forEach(lesson => {
                    try { const lessonDay = lesson[columnMap['day']]?.trim(); const weekString = lesson[columnMap['realweeks']]; const subject = lesson[columnMap['subject']]?.trim().toLowerCase(); const startStr = lesson[columnMap['starttime']]; const lenStr = lesson[columnMap['length']]; const teacherStr = lesson[columnMap['teacher']]; if (!lessonDay || !weekString || !subject || !startStr || !lenStr) return; const lessonWeeks = parseRealWeeks(weekString); if (lessonDay !== checkDay || !lessonWeeks.has(checkWeekNum)) return; const lessonStart = timeToMinutes(startStr); const lessonLength = parseInt(lenStr, 10); if (isNaN(lessonLength) || lessonLength <= 0 || lessonStart === 0 && startStr !== '00:00' && startStr !== '0000') return; /* Check for 0 from invalid time */ const lessonEnd = lessonStart + lessonLength; if (checkTimeInMinutes >= lessonStart && checkTimeInMinutes < lessonEnd) { const teachers = parseTeachers(teacherStr); if (subject === ARBETSTID_SUBJECT) { teachers.forEach(t => workingTeachers.add(t)); } else if (subject === ON_CALL_SUBJECT) { teachers.forEach(t => { workingTeachers.add(t); if (!onCallTimesMap.has(t)) { onCallTimesMap.set(t, { start: lessonStart, end: lessonEnd }); } }); } else { teachers.forEach(t => busyTeachers.add(t)); } } } catch (e) { console.error("Error processing lesson row (getAvailabilityAtTime):", lesson, e); }
                });

                let availableAndNotBusy = [...workingTeachers].filter(teacher => !busyTeachers.has(teacher));
                // Use the simple isTeacherAbsent check for specific moment
                let availableTeacherNames = availableAndNotBusy.filter(teacher => !isTeacherAbsent(teacher, dateTime, checkTimeInMinutes));

                return { available: availableTeacherNames.sort(), onCallTimes: onCallTimesMap };
            } catch (error) { console.error("Critical Error in getAvailabilityAtTime:", error); statusNow.textContent = `Error calculating availability: ${error.message}`; statusNow.classList.add('error'); return defaultResult; }
        }

        /**
         * Finds teachers available for an *entire time range*.
         * @param {Date} checkDate The date to check.
         * @param {number} checkStartMinutes The start of the range (in minutes).
         * @param {number} checkEndMinutes The end of the range (in minutes).
         * @returns {{available: string[], onCallTimes: Map<string, {start: number, end: number}>}}
         */
        function getAvailabilityForRange(checkDate, checkStartMinutes, checkEndMinutes) {
            const defaultResult = { available: [], onCallTimes: new Map() };
            try {
                if (!Array.isArray(lessons) || lessons.length === 0) { console.log("getAvailabilityForRange: No lessons."); return defaultResult; }
                let workingTeachers = new Set(); const onCallTimesMap = new Map(); const busyTeachers = new Set();
                const weekInfo = getIsoWeekAndYear(checkDate); if (!weekInfo) { console.error("getIsoWeekAndYear failed in getAvailabilityForRange"); return defaultResult; } const { week: checkWeekNum, year: checkWeekYear } = weekInfo;
                const checkDay = DAY_MAP[checkDate.getDay()];

                lessons.forEach(lesson => {
                    try {
                        const lessonDay = lesson[columnMap['day']]?.trim();
                        const weekString = lesson[columnMap['realweeks']];
                        const subject = lesson[columnMap['subject']]?.trim().toLowerCase();
                        const startStr = lesson[columnMap['starttime']];
                        const lenStr = lesson[columnMap['length']];
                        const teacherStr = lesson[columnMap['teacher']];
                        if (!lessonDay || !weekString || !subject || !startStr || !lenStr) return;
                        const lessonWeeks = parseRealWeeks(weekString);
                        if (lessonDay !== checkDay || !lessonWeeks.has(checkWeekNum)) return;
                        const lessonStart = timeToMinutes(startStr); // Uses original timeToMinutes
                        const lessonLength = parseInt(lenStr, 10);
                        // Original check for invalid lessonStart returning 0
                        if (isNaN(lessonLength) || lessonLength <= 0 || (lessonStart === 0 && startStr !== '00:00' && startStr !== '0000')) return;
                        const lessonEnd = lessonStart + lessonLength;
                        const teachers = parseTeachers(teacherStr);
                        // Teacher must be working for the *entire* duration
                        const containsQuery = (lessonStart <= checkStartMinutes && lessonEnd >= checkEndMinutes); // Original check
                        // Teacher is busy if they *overlap at all*
                        const overlapsQuery = (lessonStart < checkEndMinutes && lessonEnd > checkStartMinutes); // Original check

                        if (subject === ARBETSTID_SUBJECT) {
                            if (containsQuery) teachers.forEach(t => workingTeachers.add(t)); // Original logic
                        } else if (subject === ON_CALL_SUBJECT) {
                            if (containsQuery) { // Original logic
                                teachers.forEach(t => {
                                    workingTeachers.add(t);
                                    if (!onCallTimesMap.has(t)) { onCallTimesMap.set(t, { start: lessonStart, end: lessonEnd }); }
                                });
                            }
                        } else if (overlapsQuery) { // Original logic
                            teachers.forEach(t => busyTeachers.add(t));
                        }
                    } catch (e) { console.error("Error processing lesson row (getAvailabilityForRange):", lesson, e); }
                });

                let availableAndNotBusy = [...workingTeachers].filter(teacher => !busyTeachers.has(teacher));

                // Filter out anyone who has an absence that *overlaps* this range
                let availableTeacherNames = availableAndNotBusy.filter(teacher =>
                    !isTeacherAbsentForRange(teacher, checkDate, checkStartMinutes, checkEndMinutes)
                );

                return { available: availableTeacherNames.sort(), onCallTimes: onCallTimesMap };
            } catch (error) {
                console.error("Critical Error in getAvailabilityForRange:", error);
                statusCustom.textContent = `Error calculating availability: ${error.message}`;
                statusCustom.style.display = 'block';
                statusCustom.classList.add('error');
                return defaultResult;
            }
        }


        // --- 6. UI/DISPLAY FUNCTIONS ---
        // All functions that modify the DOM to show information to the user.

        /**
         * Renders the list of available teachers in the specified UI elements.
         * NOW correctly calculates totals from the new data structure.
         * @param {string[]} availableTeachers - Array of teacher names.
         * @param {Map} onCallTimesMap - Map of on-call teachers and their times.
         * @param {HTMLElement} listElement - The <ul> element to populate.
         * @param {HTMLElement} statusElement - The status <div> element to update.
         * @param {Date} checkDate - The date of the check (for calculating totals).
         */
        function displayResults(availableTeachers, onCallTimesMap, listElement, statusElement, checkDate) {
            listElement.innerHTML = '';
            const filteredTeachers = availableTeachers.filter(teacher => !EXCLUDE_TEACHERS_SET.has(teacher));
            const allData = getStorageData(MINUTES_STORAGE_KEY); // Use new key
            const { week: checkWeekNum, year: checkWeekYear } = getIsoWeekAndYear(checkDate);
            const checkMonthKey = `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
            if (filteredTeachers.length === 0) {
                statusElement.textContent = 'No available teachers found.';
                statusElement.classList.remove('error');
            } else {
                filteredTeachers.forEach(teacher => {
                    const li = document.createElement('li');
                    let weeklyTotal = 0;
                    let monthlyTotal = 0;
                    const teacherData = allData[teacher] || {};
                    // Iterate through dates for the teacher
                    for (const dateKey in teacherData) {
                        try {
                            const dateEntries = teacherData[dateKey]; // Should be an array
                            // Check if it's the new array format
                            if (Array.isArray(dateEntries)) {
                                const entryDate = new Date(dateKey + 'T00:00:00Z'); // Use Z for UTC date
                                if (isNaN(entryDate.getTime())) continue;
                                const { week: entryWeek, year: entryYear } = getIsoWeekAndYear(entryDate);

                                // Sum minutes from all entries for this date
                                const dailyMinutes = dateEntries.reduce((sum, entry) => sum + (entry.minutes || 0), 0);

                                if (entryWeek === checkWeekNum && entryYear === checkWeekYear) {
                                    weeklyTotal += dailyMinutes;
                                }
                                if (dateKey.startsWith(checkMonthKey)) {
                                    monthlyTotal += dailyMinutes;
                                }
                            } else {
                                // This case should ideally not happen after migration, but handle defensively
                                console.warn(`Unexpected data format for ${teacher} on ${dateKey}:`, dateEntries);
                            }
                        } catch (e) { console.error("Error calculating totals for teacher:", teacher, dateKey, e); }
                    }

                    // Display logic remains the same
                    let textContent = `${teacher} (W: ${weeklyTotal} / M: ${monthlyTotal})`;
                    if (onCallTimesMap.has(teacher)) {
                        const times = onCallTimesMap.get(teacher);
                        const startTimeStr = minutesToHHMM(times.start);
                        const endTimeStr = minutesToHHMM(times.end);
                        textContent = `${teacher} (On Call: ${startTimeStr} - ${endTimeStr}) (W: ${weeklyTotal} / M: ${monthlyTotal})`;
                        li.classList.add('on-call');
                    } else {
                        if (monthlyTotal >= 180) {
                            li.classList.add('minutes-danger');
                        } else if (weeklyTotal >= 90) {
                            li.classList.add('minutes-warn');
                        }
                    }
                    li.textContent = textContent;
                    listElement.appendChild(li);
                });
            }
        }


        /**
         * Populates the staff <select> dropdowns from the allTeachers Set.
         */
        function populateStaffDropdown() {
            console.log("Populating dropdowns...");
            if (!allTeachers || !(allTeachers instanceof Set) || allTeachers.size === 0) {
                console.warn("Cannot populate dropdowns: allTeachers set is empty or invalid.");
                staffSelect.innerHTML = '<option value="">Error: No staff found</option>';
                if (absenceStaffSelect) absenceStaffSelect.innerHTML = '<option value="">Error: No staff found</option>';
                return;
            }
            try {
                const sortedTeachers = [...allTeachers].filter(teacher => teacher && !EXCLUDE_TEACHERS_SET.has(teacher)).sort();
                staffSelect.innerHTML = '<option value="">-- Select Staff --</option>';
                if (absenceStaffSelect) absenceStaffSelect.innerHTML = '<option value="">-- Select Staff --</option>';
                sortedTeachers.forEach(teacher => {
                    const option = document.createElement('option');
                    option.value = teacher;
                    option.textContent = teacher;
                    staffSelect.appendChild(option.cloneNode(true));
                    if (absenceStaffSelect) absenceStaffSelect.appendChild(option.cloneNode(true));
                });
                console.log(`Dropdowns populated with ${sortedTeachers.length} teachers.`);
            }
            catch (error) { console.error("Error during populateStaffDropdown:", error); staffSelect.innerHTML = '<option value="">Error populating</option>'; }
        }

        /**
         * Shows a temporary status message for the 'Save Minutes' action.
         * @param {string} message The message to display.
         * @param {boolean} isError True if the message is an error.
         */
        function showSaveStatus(message, isError = false) {
            if (!saveStatus) return;
            saveStatus.textContent = message;
            saveStatus.className = 'status';
            saveStatus.classList.add(isError ? 'error' : 'success');
            saveStatus.style.display = 'block';
            setTimeout(() => { if (saveStatus) saveStatus.style.display = 'none'; }, 4000);
        }

        /**
         * Shows a temporary status message for the 'Save Absence' action.
         * @param {string} message The message to display.
         * @param {boolean} isError True if the message is an error.
         */
        function showAbsenceSaveStatus(message, isError = false) {
            if (!absenceSaveStatus) return;
            absenceSaveStatus.textContent = message;
            absenceSaveStatus.className = 'status';
            absenceSaveStatus.classList.add(isError ? 'error' : 'success');
            absenceSaveStatus.style.display = 'block';
            setTimeout(() => { if (absenceSaveStatus) absenceSaveStatus.style.display = 'none'; }, 4000);
        }

        /**
         * Shows a temporary status message for the 'Import Minutes' action.
         * @param {string} message The message to display.
         * @param {boolean} isError True if the message is an error.
         */
        function showImportStatus(message, isError = false) {
            if (!importStatus) return;
            importStatus.textContent = message;
            importStatus.className = 'status';
            importStatus.classList.add(isError ? 'error' : 'success');
            importStatus.style.display = 'block';
            setTimeout(() => { if (importStatus) importStatus.style.display = 'none'; }, 5000);
        }

        /**
         * Shows a temporary status message for the 'Import Absences' action.
         * @param {string} message The message to display.
         * @param {boolean} isError True if the message is an error.
         */
        function showAbsenceImportStatus(message, isError = false) {
            if (!absenceImportStatus) return;
            absenceImportStatus.textContent = message;
            absenceImportStatus.className = 'status';
            absenceImportStatus.classList.add(isError ? 'error' : 'success');
            absenceImportStatus.style.display = 'block';
            setTimeout(() => { if (absenceImportStatus) absenceImportStatus.style.display = 'none'; }, 5000);
        }

        /**
         * Displays the list of existing absences for a given date.
         * @param {string} dateKey The date string (YYYY-MM-DD) to check.
         */
        function displayExistingAbsences(dateKey) {
            if (!existingAbsencesList) return;
            if (!dateKey) {
                existingAbsencesList.innerHTML = '<p class="status">Select a date to see existing entries.</p>';
                return;
            }
            const allAbsenceData = getStorageData(ABSENCE_STORAGE_KEY);
            let html = '';
            let foundAbsences = false;
            const staffNames = Object.keys(allAbsenceData).sort();
            staffNames.forEach(staffName => {
                if (EXCLUDE_TEACHERS_SET.has(staffName)) return;
                const dayEntries = allAbsenceData[staffName]?.[dateKey] || [];
                if (dayEntries.length > 0) {
                    foundAbsences = true;
                    html += `<h4>${staffName}</h4><ul>`;
                    dayEntries.sort((a, b) => a.start - b.start);
                    // Using index for deletion as per original working code
                    dayEntries.forEach((entry, index) => {
                        html += `
                            <li style="margin-bottom: 10px; list-style-type: none; border-bottom: 1px solid #4a6aab; padding-bottom: 10px;">
                                <strong>${minutesToHHMM(entry.start)} - ${minutesToHHMM(entry.end)}</strong>
                                <button class="danger" data-staff="${staffName}" data-date="${dateKey}" data-index="${index}" style="padding: 3px 8px; font-size: 12px; margin-left: 10px; margin-top: 0;">Delete</button>
                            </li>
                        `;
                    });
                    html += '</ul>';
                }
            });
            if (!foundAbsences) {
                existingAbsencesList.innerHTML = '<p class="status">No absences logged for any staff on this day.</p>';
            } else {
                existingAbsencesList.innerHTML = html;
            }
        }

        /**
         * Displays the total substitution minutes for all staff for a given month/year.
         * NOW correctly calculates totals from the new data structure.
         * @param {number} year The full year (e.g., 2025).
         * @param {number} monthIndex The month index (0-11).
         */
        function displayMonthlyTotals(year, monthIndex) {
            totalsDisplay.innerHTML = '';
            const monthKey = `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
            const allData = getStorageData(MINUTES_STORAGE_KEY); // Use new key
            let totals = [];
            for (const teacher in allData) {
                if (EXCLUDE_TEACHERS_SET.has(teacher)) continue;
                let monthlyTotal = 0;
                const teacherData = allData[teacher] || {};
                // Iterate through dates for the teacher
                for (const dateKey in teacherData) {
                     // Check if the date belongs to the selected month
                    if (dateKey.startsWith(monthKey)) {
                        const dateEntries = teacherData[dateKey]; // Should be an array
                        // Check if it's the new array format
                        if (Array.isArray(dateEntries)) {
                             // Sum minutes from all entries for this date
                            monthlyTotal += dateEntries.reduce((sum, entry) => sum + (entry.minutes || 0), 0);
                        } else {
                            // Defensive handling for unexpected data
                            console.warn(`Unexpected data format for ${teacher} on ${dateKey}:`, dateEntries);
                        }
                    }
                }
                 // Only add teacher if they have minutes this month
                if (monthlyTotal > 0) {
                    totals.push({ name: teacher, total: monthlyTotal });
                }
            }

            totals.sort((a, b) => a.total - b.total); // Sort by total minutes
            
            if (totals.length === 0) {
                totalsDisplay.innerHTML = `<p class="status">No extra minutes recorded for ${monthKey}.</p>`;
                return;
            }
            
            const monthName = new Date(year, monthIndex, 1).toLocaleString('default', { month: 'long' });
            let html = `<h3>Totals for ${monthName} ${year}</h3><ul style="padding: 0;">`;
            totals.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.total} minutes`;
                if (entry.total >= 180) {
                    li.classList.add('minutes-danger');
                } else if (entry.total >= 90) { // Keep weekly warning style for monthly totals >= 90
                     li.classList.add('minutes-warn');
                }
                html += li.outerHTML;
            });
            html += '</ul>';
            totalsDisplay.innerHTML = html;
        }


        /**
         * Creates the "Jan, Feb, Mar..." month buttons and attaches their click handlers.
         */
        function setupMonthButtons() {
            console.log("Attempting to set up month buttons...");
            if (!monthButtonsContainer) { console.error("Critical Error: Month buttons container not found."); return; }
            try { const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; monthButtonsContainer.innerHTML = ''; console.log("Month button container cleared."); monthNames.forEach((name, index) => { const button = document.createElement('button'); if (!button) { console.error(`Failed to create button for month ${index}`); return; } button.textContent = name; button.classList.add('secondary'); button.dataset.monthIndex = index; button.addEventListener('click', (e) => { try { if (activeMonthButton) { activeMonthButton.classList.remove('active'); activeMonthButton.classList.add('secondary'); } const clickedButton = e.target; clickedButton.classList.remove('secondary'); clickedButton.classList.add('active'); activeMonthButton = clickedButton; const yearVal = parseInt(yearDisplay.value, 10); if (isNaN(yearVal)) { totalsDisplay.innerHTML = '<p class="error">Enter valid year.</p>'; return; } displayMonthlyTotals(yearVal, index); } catch (clickHandlerError) { console.error("Error in month button click:", clickHandlerError); totalsDisplay.innerHTML = '<p class="error">Error displaying totals.</p>'; } }); monthButtonsContainer.appendChild(button); }); console.log("Finished setupMonthButtons loop successfully."); }
            catch (error) { console.error("Critical Error during setupMonthButtons loop:", error); monthButtonsContainer.innerHTML = '<p class="error" style="color: red;">Error creating month buttons.</p>'; }
        }

        /**
         * Refreshes the "Existing Absences" list based on the currently selected date.
         */
        function refreshAbsenceList() {
            const date = absenceDateInput.value;
            displayExistingAbsences(date);
        }

        /**
         * Reruns all availability checks to refresh the UI.
         * Used after data changes (saving/deleting minutes/absences).
         */
        function refreshAllAvailabilityViews() {
            // Refresh "Available Right Now"
            const now = new Date();
            const availabilityNow = getAvailabilityAtTime(now);
            displayResults(availabilityNow.available, availabilityNow.onCallTimes, teachersNowList, statusNow, now);
            statusNow.textContent = `Schedule updated. Checked: ${now.toLocaleString()}`;
            
            // If the "Custom Check" has results, refresh it too
            if (teachersCustomList.innerHTML !== '') {
                handleCheckAvailability();
            }
        }

        // --- 7. EVENT HANDLERS ---
        // These functions are called directly by event listeners (e.g., 'click').

        /**
         * Handles the "Check Availability" button click.
         */
        function handleCheckAvailability() {
            try {
                const date = dateInput.valueAsDate;
                const timeFrom = timeFromInput.value;
                const timeTo = timeToInput.value;

                if (!date || !timeFrom || !timeTo) {
                    statusCustom.textContent = 'Please select a date and a time range.';
                    statusCustom.style.display = 'block';
                    statusCustom.classList.add('error');
                    teachersCustomList.innerHTML = '';
                    return;
                }

                const startMinutes = timeToMinutes(timeFrom); // Uses original timeToMinutes
                const endMinutes = timeToMinutes(timeTo);     // Uses original timeToMinutes

                if (startMinutes >= endMinutes && !(startMinutes === 0 && endMinutes === 0)) {
                    statusCustom.textContent = 'Invalid time: "From" time must be before "To" time.';
                    statusCustom.style.display = 'block';
                    statusCustom.classList.add('error');
                    teachersCustomList.innerHTML = '';
                    return;
                }

                statusCustom.textContent = `Checking for: ${date.toDateString()} from ${timeFrom} to ${timeTo}...`;
                statusCustom.style.display = 'block';
                statusCustom.classList.remove('error');

                const availability = getAvailabilityForRange(date, startMinutes, endMinutes);
                displayResults(availability.available, availability.onCallTimes, teachersCustomList, statusCustom, date);
            } catch (e) {
                console.error("Error in checkButton click:", e);
                statusCustom.textContent = `An error occurred: ${e.message}`;
                statusCustom.style.display = 'block';
                statusCustom.classList.add('error');
            }
        }

        /**
         * Handles the "Save Minutes" button click.
         * NOW SAVES AS AN ENTRY IN AN ARRAY.
         */
        function handleSaveMinutes() {
            const staffName = staffSelect.value;
            const date = dateEntryInput.value;
            const minutes = parseInt(minutesInput.value, 10);

            if (!staffName || !date || isNaN(minutes) || minutes <= 0) {
                showSaveStatus('Please select a staff member, valid date, and enter positive minutes.', true);
                return;
            }
            try {
                const allData = getStorageData(MINUTES_STORAGE_KEY); // Use new key
                if (!allData[staffName]) allData[staffName] = {};
                // Ensure the entry for the date is an array
                if (!Array.isArray(allData[staffName][date])) {
                    allData[staffName][date] = []; // Initialize as array if not already
                }

                // Add the new entry
                const newEntry = {
                    minutes: minutes,
                    timestamp: Date.now() // Record when it was added
                };
                allData[staffName][date].push(newEntry);

                saveMinutesData(allData); // Save using the correct key

                // Calculate the new total for the day for the status message
                const newTotalForDay = allData[staffName][date].reduce((sum, entry) => sum + (entry.minutes || 0), 0);
                showSaveStatus(`Added ${minutes} min entry for ${staffName} on ${date}. New total for day: ${newTotalForDay}`, false);

                minutesInput.value = ''; // Clear input
                
                // Refresh totals and availability
                if (activeMonthButton) {
                    const yearVal = parseInt(yearDisplay.value, 10);
                    const monthIndex = parseInt(activeMonthButton.dataset.monthIndex, 10);
                    if (!isNaN(yearVal) && !isNaN(monthIndex)) {
                        displayMonthlyTotals(yearVal, monthIndex);
                    }
                }
                refreshAllAvailabilityViews();

            } catch (e) {
                console.error("Error saving minutes:", e);
                showSaveStatus(`Error saving: ${e.message}`, true);
            }
        }


        /**
         * Handles the "Export Summary CSV" button click (Monthly/Weekly Totals).
         * Uses SEMICOLONS. Calculates totals from the new data structure.
         */
        function handleExportSummary() {
            try {
                const allData = getStorageData(MINUTES_STORAGE_KEY); // Use new key
                // USE SEMICOLON as separator
                let csvContent = "data:text/csv;charset=utf-8,Date of Export;Staff Name;Month;Month Total;Week;Week Total\r\n";
                const exportDate = new Date().toISOString().split('T')[0];
                let entries = [];

                // Iterate through teachers
                for (const teacher in allData) {
                    if (EXCLUDE_TEACHERS_SET.has(teacher)) continue;
                    const teacherData = allData[teacher];
                    let totalsByMonth = {};
                    let totalsByWeek = {};

                    // Iterate through dates for the teacher
                    for (const dateKey in teacherData) {
                        const dateEntries = teacherData[dateKey]; // Should be an array
                        if (!Array.isArray(dateEntries)) continue; // Skip if not array

                         // Sum minutes for the day
                        const dailyMinutes = dateEntries.reduce((sum, entry) => sum + (entry.minutes || 0), 0);
                        if (dailyMinutes === 0) continue; // Skip if no minutes for the day

                        // Calculate Month Total
                        const monthKey = dateKey.substring(0, 7);
                        totalsByMonth[monthKey] = (totalsByMonth[monthKey] || 0) + dailyMinutes;

                        // Calculate Week Total
                        try {
                            const entryDate = new Date(dateKey + 'T00:00:00Z');
                            if (isNaN(entryDate.getTime())) continue;
                            const { weekKey } = getIsoWeekAndYear(entryDate);
                            totalsByWeek[weekKey] = (totalsByWeek[weekKey] || 0) + dailyMinutes;
                        } catch (e) { console.error("Error processing date for week calculation:", dateKey, e); }
                    }
                    // Only add if there are any totals for this teacher
                    if (Object.keys(totalsByMonth).length > 0 || Object.keys(totalsByWeek).length > 0) {
                         entries.push({ teacher, totalsByMonth, totalsByWeek });
                    }
                }

                entries.sort((a, b) => a.teacher.localeCompare(b.teacher));

                entries.forEach(entry => {
                    const { teacher, totalsByMonth, totalsByWeek } = entry;
                    const allMonthKeys = Object.keys(totalsByMonth).sort();
                    const allWeekKeys = Object.keys(totalsByWeek).sort();
                    let i = 0, j = 0;
                    // Ensure quotes around teacher name
                    const safeTeacher = `"${teacher.replace(/"/g, '""')}"`;
                    // Output rows combining month/week data where possible
                    while (i < allMonthKeys.length || j < allWeekKeys.length) {
                        const monthKey = allMonthKeys[i] || '';
                        const monthTotal = totalsByMonth[monthKey] || '';
                        const weekKey = allWeekKeys[j] || '';
                        const weekTotal = totalsByWeek[weekKey] || '';
                        // USE SEMICOLON as separator
                        csvContent += `${exportDate};${safeTeacher};${monthKey};${monthTotal};${weekKey};${weekTotal}\r\n`;
                        // Increment pointers - simple approach, might list weeks/months separately if counts differ
                        if (i < allMonthKeys.length) i++;
                        if (j < allWeekKeys.length) j++;
                    }
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `Extra_Minutes_Summary_Totals_${exportDate}.csv`); // Updated filename
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                console.error("Error exporting summary:", e);
                showImportStatus(`Error exporting summary: ${e.message}`, true);
            }
        }


        /**
         * Handles the "Export CSV (Entries)" button click (individual entries backup).
         * NOW USES SEMICOLONS and exports each entry.
         */
        function handleExportBackup() {
            try {
                const allData = getStorageData(MINUTES_STORAGE_KEY); // Use new key
                 // USE SEMICOLON as separator, add Timestamp column
                let csvContent = "data:text/csv;charset=utf-8,Date;Staff;Minutes;Timestamp\r\n";
                let entries = [];

                // Iterate through teachers
                for (const teacher in allData) {
                    const teacherData = allData[teacher];
                     // Iterate through dates for the teacher
                    for (const dateKey in teacherData) {
                        const dateEntries = teacherData[dateKey]; // Should be an array
                         // Iterate through individual entries for the day
                        if (Array.isArray(dateEntries)) {
                            dateEntries.forEach(entry => {
                                if (entry && typeof entry.minutes === 'number' && entry.minutes > 0) {
                                    entries.push({
                                        date: dateKey,
                                        staff: teacher,
                                        minutes: entry.minutes,
                                        // Format the timestamp, handle potentially missing ones
                                        timestamp: entry.timestamp ? formatTimestamp(entry.timestamp) : '' 
                                    });
                                }
                            });
                        }
                    }
                }

                // Sort entries primarily by date, then staff, then timestamp
                entries.sort((a, b) => {
                    if (a.date < b.date) return -1;
                    if (a.date > b.date) return 1;
                    if (a.staff < b.staff) return -1;
                    if (a.staff > b.staff) return 1;
                    // Sort by timestamp if available (treat missing timestamp as earliest)
                    const tsA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
                    const tsB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
                    return tsA - tsB;
                });

                entries.forEach(entry => {
                    // Ensure quotes around teacher name and timestamp
                    const safeStaff = `"${entry.staff.replace(/"/g, '""')}"`;
                    const safeTimestamp = `"${entry.timestamp.replace(/"/g, '""')}"`;
                    // USE SEMICOLON as separator
                    csvContent += `${entry.date};${safeStaff};${entry.minutes};${safeTimestamp}\r\n`; 
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                const exportDate = new Date().toISOString().split('T')[0];
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `Extra_Minutes_Backup_Entries_${exportDate}.csv`); // Updated filename
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showImportStatus('Minutes Backup (Entries) CSV exported successfully.', false);
            } catch (e) {
                console.error("Error exporting minutes backup:", e);
                showImportStatus(`Error exporting minutes backup: ${e.message}`, true);
            }
        }


        /**
         * Handles the "Clear All Saved Data" button click.
         */
        function handleClearData() {
            console.log("Clear data button clicked");
            // NOTE: Using confirm(). A custom modal is more robust in restricted environments.
            const reallyClear = confirm("Are you sure you want to delete ALL saved extra minutes AND absence data? This cannot be undone.");
            if (reallyClear) {
                try {
                    localStorage.removeItem(MINUTES_STORAGE_KEY); // Remove new format
                    localStorage.removeItem(OLD_MINUTES_STORAGE_KEY); // Remove old format just in case
                    localStorage.removeItem(ABSENCE_STORAGE_KEY);
                    showImportStatus('All extra minutes and absence data have been cleared.', false);
                    
                    // Refresh all UI elements
                    refreshAbsenceList();
                    if (activeMonthButton) {
                        const yearVal = parseInt(yearDisplay.value, 10);
                        const monthIndex = parseInt(activeMonthButton.dataset.monthIndex, 10);
                        if (!isNaN(yearVal) && !isNaN(monthIndex)) {
                            displayMonthlyTotals(yearVal, monthIndex); // Will show "No extra minutes recorded"
                        } else {
                            totalsDisplay.innerHTML = '<p>Select a month to see totals.</p>';
                        }
                    } else {
                        totalsDisplay.innerHTML = '<p>Select a month to see totals.</p>';
                    }
                    refreshAllAvailabilityViews(); // Will show totals as 0

                } catch (e) {
                    console.error("Error clearing data:", e);
                    showImportStatus(`Error clearing data: ${e.message}`, true);
                }
            } else {
                showImportStatus('Clear data operation cancelled.', true);
            }
        }

        /**
         * Handles the Year input field changing.
         */
        function handleYearChange() {
            if (activeMonthButton) {
                const yearVal = parseInt(yearDisplay.value, 10);
                const monthIndex = parseInt(activeMonthButton.dataset.monthIndex, 10);
                if (!isNaN(yearVal) && !isNaN(monthIndex)) {
                    displayMonthlyTotals(yearVal, monthIndex);
                }
            }
        }

        /**
         * Handles the "Import CSV (Entries)" button click (triggers file input).
         */
        function handleImportMinutesClick() {
            csvFileInput.value = null; // Reset file input
            csvFileInput.click();
        }

        /**
         * Handles the file selection for importing minutes.
         * NOW DETECTS COMMA OR SEMICOLON. Imports each row as a NEW ENTRY.
         * Timestamp column is optional on import.
         * @param {Event} event The file input change event.
         */
        function handleMinutesFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                showImportStatus('No file selected.', true);
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
                    if (lines.length < 2) throw new Error("CSV file is empty or has no header/data.");

                    // --- Delimiter Detection ---
                    let delimiter = ',';
                    if (lines[0].includes(';')) {
                         if (lines[0].split(';').length > lines[0].split(',').length) {
                             delimiter = ';';
                         }
                    }
                    console.log("Detected delimiter:", delimiter);
                    // --------------------------

                    const header = lines[0].toLowerCase().split(delimiter).map(h => h.trim().replace(/^"|"$/g, ''));
                    const dateIndex = header.indexOf('date');
                    const staffIndex = header.indexOf('staff');
                    const minutesIndex = header.indexOf('minutes');
                    const timestampIndex = header.indexOf('timestamp'); // Optional

                    if (dateIndex === -1 || staffIndex === -1 || minutesIndex === -1) {
                        throw new Error(`Invalid Minutes CSV Header. Must contain at least 'Date', 'Staff', and 'Minutes' columns separated by '${delimiter}'.`);
                    }

                    let importedCount = 0;
                    let skippedCount = 0;
                    const currentMinutesData = getStorageData(MINUTES_STORAGE_KEY); // Use new key

                    for (let i = 1; i < lines.length; i++) {
                        const columns = parseCsvLine(lines[i], delimiter); 
                        
                        if (columns.length <= Math.max(dateIndex, staffIndex, minutesIndex)) {
                            console.warn(`Skipping short/malformed line ${i + 1}:`, lines[i]);
                            skippedCount++;
                            continue;
                        }

                        const date = columns[dateIndex]?.trim();
                        const staff = columns[staffIndex]?.trim();
                        const minutesStr = columns[minutesIndex]?.trim();
                        const minutes = parseInt(minutesStr, 10);
                        // Timestamp is optional, try to parse if present
                        let timestamp = Date.now(); // Default to now if not provided/invalid
                        if (timestampIndex !== -1 && columns[timestampIndex]) {
                             const tsString = columns[timestampIndex]?.trim();
                             try {
                                 const parsedTs = new Date(tsString).getTime();
                                 if (!isNaN(parsedTs)) {
                                     timestamp = parsedTs;
                                 }
                             } catch (tsError) {
                                 console.warn(`Could not parse timestamp on line ${i+1}, using current time:`, tsString);
                             }
                        }


                        // Validate essential data
                        if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date) || !staff || !minutesStr || isNaN(minutes) || minutes <= 0) {
                            console.warn(`Skipping invalid data on line ${i + 1}:`, lines[i]);
                            skippedCount++;
                            continue;
                        }

                        // --- Import Logic: Add as new entry ---
                        if (!currentMinutesData[staff]) currentMinutesData[staff] = {};
                        if (!Array.isArray(currentMinutesData[staff][date])) {
                             currentMinutesData[staff][date] = []; // Ensure it's an array
                        }
                        
                        // Add the imported row as a new entry object
                        currentMinutesData[staff][date].push({
                            minutes: minutes,
                            timestamp: timestamp
                        });
                        importedCount++;
                        // --- End Import Logic ---
                    }

                    saveMinutesData(currentMinutesData); // Save updated data
                    showImportStatus(`Minutes Import complete: ${importedCount} minute entries ADDED. ${skippedCount} lines skipped. Note: Importing the same file multiple times will create duplicates.`, false);
                    
                    // Refresh UI
                    if (activeMonthButton) activeMonthButton.click(); // Re-render totals
                    refreshAllAvailabilityViews(); // Refresh availability

                } catch (err) {
                    console.error("Error processing minutes CSV:", err);
                    showImportStatus(`Minutes Import Error: ${err.message}`, true);
                }
            };
            reader.onerror = (err) => {
                 console.error("FileReader error:", err);
                 showImportStatus(`Error reading file: ${err}`, true);
            };
            reader.readAsText(file);
        }

        /**
         * Handles the "Save Absence" button click.
         */
        function handleSaveAbsence() {
            const staffName = absenceStaffSelect.value;
            const date = absenceDateInput.value;
            const timeFrom = absenceTimeFromInput.value;
            const timeTo = absenceTimeToInput.value;
            if (!staffName || !date || !timeFrom || !timeTo) {
                showAbsenceSaveStatus('Please select staff, date, and a full time range.', true);
                return;
            }
            const startMinutes = timeToMinutes(timeFrom); // Uses original timeToMinutes
            const endMinutes = timeToMinutes(timeTo);     // Uses original timeToMinutes
            if (startMinutes >= endMinutes && !(startMinutes === 0 && endMinutes === 0)) {
                showAbsenceSaveStatus('Invalid time: "From" time must be before "To" time.', true);
                return;
            }
            try {
                const allData = getStorageData(ABSENCE_STORAGE_KEY);
                if (!allData[staffName]) allData[staffName] = {};
                if (!allData[staffName][date]) allData[staffName][date] = [];
                allData[staffName][date].push({ start: startMinutes, end: endMinutes });
                saveAbsenceData(allData);
                showAbsenceSaveStatus(`Saved absence for ${staffName} on ${date} (${timeFrom} - ${timeTo}).`, false);
                absenceTimeFromInput.value = '';
                absenceTimeToInput.value = '';
                
                // Refresh UI
                refreshAbsenceList();
                refreshAllAvailabilityViews();

            } catch (e) {
                console.error("Error saving absence:", e);
                showAbsenceSaveStatus(`Error saving: ${e.message}`, true);
            }
        }

        /**
         * Handles clicks within the "Existing Absences" list (for deletion).
         * @param {Event} e The click event.
         */
        function handleDeleteAbsence(e) {
            if (e.target.tagName === 'BUTTON' && e.target.classList.contains('danger')) {
                const { staff, date, index } = e.target.dataset; // Use index as per original
                if (!staff || !date || index === undefined) {
                    console.error("Missing data attributes for deletion:", e.target.dataset);
                    return;
                }
                try {
                    const idx = parseInt(index, 10); // Parse index
                    if (isNaN(idx)) {
                        console.error("Invalid index for deletion:", index);
                        return;
                    }
                    const allData = getStorageData(ABSENCE_STORAGE_KEY);
                    if (allData[staff]?.[date]?.[idx] !== undefined) { // Check if entry exists at index
                        allData[staff][date].splice(idx, 1); // Remove by index
                        if (allData[staff][date].length === 0) delete allData[staff][date];
                        if (Object.keys(allData[staff] || {}).length === 0) delete allData[staff];
                        saveAbsenceData(allData);
                        showAbsenceSaveStatus('Absence entry deleted.', false);
                        
                        // Refresh UI
                        refreshAbsenceList(); // Refresh list to update indices
                        refreshAllAvailabilityViews();

                    } else {
                        console.warn("Attempted to delete non-existent absence entry (by index):", { staff, date, index });
                    }
                } catch (err) {
                    console.error("Error deleting absence:", err);
                    showAbsenceSaveStatus(`Error deleting: ${err.message}`, true);
                }
            }
        }

        /**
         * Handles the "Export Absences CSV" button click.
         * Uses SEMICOLONS.
         */
        function handleExportAbsences() {
            try {
                const absenceData = getStorageData(ABSENCE_STORAGE_KEY);
                // USE SEMICOLON as separator
                let csvContent = "data:text/csv;charset=utf-8,Date;Staff;StartTime;EndTime\r\n"; 
                let entries = [];
                for (const teacher in absenceData) {
                    const teacherDateData = absenceData[teacher];
                    for (const dateKey in teacherDateData) {
                        const dayEntries = teacherDateData[dateKey] || [];
                        dayEntries.forEach(entry => {
                            if (typeof entry.start === 'number' && typeof entry.end === 'number') {
                                entries.push({
                                    date: dateKey,
                                    staff: teacher,
                                    startTime: minutesToHHMM(entry.start),
                                    endTime: minutesToHHMM(entry.end)
                                });
                            }
                        });
                    }
                }
                entries.sort((a, b) => { // Sort logic remains the same
                    if (a.date < b.date) return -1;
                    if (a.date > b.date) return 1;
                    if (a.staff < b.staff) return -1;
                    if (a.staff > b.staff) return 1;
                    let startA = timeToMinutes(a.startTime); 
                    let startB = timeToMinutes(b.startTime); 
                    return startA - startB; // Corrected calculation
                });
                entries.forEach(entry => {
                     // Ensure quotes around teacher name
                    const safeStaff = `"${entry.staff.replace(/"/g, '""')}"`;
                    // USE SEMICOLON as separator
                    csvContent += `${entry.date};${safeStaff};${entry.startTime};${entry.endTime}\r\n`; 
                });
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                const exportDate = new Date().toISOString().split('T')[0];
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `Teacher_Absences_Backup_${exportDate}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showAbsenceImportStatus('Absences CSV exported successfully.', false);
            } catch (e) {
                console.error("Error exporting absences:", e);
                showAbsenceImportStatus(`Error exporting absences: ${e.message}`, true);
            }
        }

        /**
         * Handles the "Import Absences CSV" button click (triggers file input).
         */
        function handleImportAbsencesClick() {
            absenceCsvFileInput.value = null; // Reset file input
            absenceCsvFileInput.click();
        }

        /**
         * Handles the file selection for importing absences.
         * DETECTS COMMA OR SEMICOLON.
         * @param {Event} event The file input change event.
         */
        function handleAbsenceFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                showAbsenceImportStatus('No file selected.', true);
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
                    if (lines.length < 2) throw new Error("Absence CSV file is empty or has no header/data.");

                     // --- Delimiter Detection ---
                    let delimiter = ','; 
                    if (lines[0].includes(';')) { 
                         if (lines[0].split(';').length > lines[0].split(',').length) {
                             delimiter = ';';
                         }
                    }
                    console.log("Detected delimiter:", delimiter);
                    // --------------------------

                    const header = lines[0].toLowerCase().split(delimiter).map(h => h.trim().replace(/^"|"$/g, ''));
                    const dateIndex = header.indexOf('date');
                    const staffIndex = header.indexOf('staff');
                    const startTimeIndex = header.indexOf('starttime');
                    const endTimeIndex = header.indexOf('endtime');

                    if (dateIndex === -1 || staffIndex === -1 || startTimeIndex === -1 || endTimeIndex === -1) {
                        throw new Error(`Invalid Absence CSV Header. Must contain 'Date', 'Staff', 'StartTime', and 'EndTime' columns separated by '${delimiter}'.`);
                    }

                    let importedCount = 0;
                    let skippedCount = 0;
                    const currentAbsenceData = getStorageData(ABSENCE_STORAGE_KEY);

                    for (let i = 1; i < lines.length; i++) {
                        const columns = parseCsvLine(lines[i], delimiter); 

                        if (columns.length <= Math.max(dateIndex, staffIndex, startTimeIndex, endTimeIndex)) { 
                            console.warn(`Skipping short/malformed absence line ${i + 1}:`, lines[i]);
                            skippedCount++;
                            continue;
                        }

                        const date = columns[dateIndex]?.trim();
                        const staff = columns[staffIndex]?.trim();
                        const startTimeStr = columns[startTimeIndex]?.trim();
                        const endTimeStr = columns[endTimeIndex]?.trim();

                        if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date) || !staff || !startTimeStr || !endTimeStr) {
                            console.warn(`Skipping absence line ${i + 1} with missing/invalid data:`, lines[i]);
                            skippedCount++;
                            continue;
                        }

                        const startMinutes = timeToMinutes(startTimeStr); 
                        const endMinutes = timeToMinutes(endTimeStr);     

                        if (startMinutes >= endMinutes && !(startMinutes === 0 && endMinutes === 0)) {
                            console.warn(`Skipping absence line ${i + 1} with invalid time range:`, lines[i]);
                            skippedCount++;
                            continue;
                        }

                        if (!currentAbsenceData[staff]) currentAbsenceData[staff] = {};
                        if (!Array.isArray(currentAbsenceData[staff][date])) {
                             currentAbsenceData[staff][date] = []; 
                        }
                        
                        // Add if not already present
                        const exists = currentAbsenceData[staff][date].some(entry => entry.start === startMinutes && entry.end === endMinutes);
                        if (!exists) {
                            currentAbsenceData[staff][date].push({ start: startMinutes, end: endMinutes });
                            importedCount++;
                        } else {
                            console.log(`Skipping duplicate absence entry on line ${i + 1}:`, lines[i]);
                        }
                    }

                    saveAbsenceData(currentAbsenceData); // Save updated data
                    showAbsenceImportStatus(`Absences Import complete: ${importedCount} new entries added. ${skippedCount} lines skipped.`, false);
                    
                    // Refresh UI
                    refreshAbsenceList(); 
                    refreshAllAvailabilityViews();

                } catch (err) {
                    console.error("Error processing absence CSV:", err);
                    showAbsenceImportStatus(`Absence Import Error: ${err.message}`, true);
                }
            };
            reader.onerror = (err) => {
                 console.error("FileReader error:", err);
                 showAbsenceImportStatus(`Error reading file: ${err}`, true);
            };
            reader.readAsText(file);
        }


        // --- 8. INITIALIZATION & MIGRATION ---
        // The main function to load data and set up the app.
        // Includes data migration from old format.

        /**
         * Migrates old minutes data format (number) to new format (array of objects).
         * This runs once when the application loads if old data is detected.
         */
        function migrateOldMinutesData() {
            const oldData = getStorageData(OLD_MINUTES_STORAGE_KEY);
            if (Object.keys(oldData).length === 0) {
                 console.log("No old minutes data found to migrate.");
                 return; // No old data exists
            }

            console.log("Old minutes data format detected. Starting migration...");
            const newData = {};
            let migratedEntries = 0;

            for (const teacher in oldData) {
                newData[teacher] = {};
                const teacherData = oldData[teacher];
                for (const dateKey in teacherData) {
                    const minutes = teacherData[dateKey];
                    // Check if it's the old numeric format
                    if (typeof minutes === 'number' && minutes > 0) {
                        // Convert to new array format with a single entry
                        newData[teacher][dateKey] = [{
                            minutes: minutes,
                            timestamp: Date.now() // Use current time as timestamp for migrated data
                        }];
                        migratedEntries++;
                    } else if (Array.isArray(minutes)) {
                         // If somehow it's already an array, just copy it (unlikely but safe)
                         newData[teacher][dateKey] = minutes;
                    }
                }
            }

            // Save the newly formatted data under the new key
            saveMinutesData(newData);
            // Optionally remove the old data after successful migration
            localStorage.removeItem(OLD_MINUTES_STORAGE_KEY); 
            console.log(`Migration complete. Converted ${migratedEntries} daily totals to the new entry format. Old data removed.`);
            showImportStatus(`Migrated old minutes data to new format.`, false); // Inform user
        }


        /**
         * Fetches and parses the Lessons.txt file, then initializes the UI.
         * Now includes migration step.
         */
        async function loadData() {
            console.log("Starting application load...");

            // --- Attempt Migration Before Loading Data ---
            try {
                migrateOldMinutesData();
            } catch (migrationError) {
                console.error("CRITICAL ERROR during data migration:", migrationError);
                // Decide how to handle migration failure - maybe alert user?
                // For now, continue loading, but calculations might be wrong if migration failed partially.
                showImportStatus("Error migrating old data. Totals might be incorrect. Check console.", true);
            }
            // --- End Migration Step ---

            statusNow.textContent = 'Loading schedule...';
            statusNow.classList.remove('error', 'success');
            try {
                console.log("Fetching Lessons.txt...");
                const response = await fetch(`Lessons.txt?v=${new Date().getTime()}`);
                if (!response.ok) throw new Error(`Fetch failed: ${response.statusText} (${response.status})`);
                console.log("Fetched OK."); const text = await response.text();
                const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
                if (lines.length < 2) throw new Error('Lessons.txt is empty or invalid.'); console.log(`Read ${lines.length} lines.`);
                const header = lines[0].split('\t'); columnMap = {}; header.forEach((c, i) => { columnMap[c.trim()] = i; }); console.log("Parsed header."); const requiredCols = ['subject', 'teacher', 'day', 'starttime', 'length', 'realweeks']; for (const col of requiredCols) { if (columnMap[col] === undefined) throw new Error(`Missing required column: ${col}`); } console.log("Required columns found.");
                const expectedColumns = header.length;
                lessons = lines.slice(1).map((line, index) => { const columns = line.split('\t'); if (columns.length !== expectedColumns) { while (columns.length < expectedColumns) columns.push(''); if (columns.length > expectedColumns) columns.length = expectedColumns; } return columns; }).filter(row => row); console.log(`Parsed ${lessons.length} lesson rows.`);

                allTeachers = new Set();
                const teacherColIndex = columnMap['teacher']; if (typeof teacherColIndex !== 'number') { throw new Error("Could not find 'teacher' column index."); }
                console.log("Starting teacher population loop...");
                lessons.forEach((lesson, index) => { const rowNum = index + 2; try { if (!Array.isArray(lesson) || lesson.length <= teacherColIndex) { return; } const teacherStringRaw = lesson[teacherColIndex]; if (typeof teacherStringRaw === 'string' && teacherStringRaw.trim()) { const teacherString = teacherStringRaw.trim(); const parsedResult = parseTeachers(teacherString); if (Array.isArray(parsedResult)) { parsedResult.forEach(teacher => { if (teacher) allTeachers.add(teacher); }); } } } catch (e) { console.error(`Critical error processing teachers row ${rowNum}:`, lesson, e); } });
                console.log(`Finished teacher population loop. Found ${allTeachers.size} unique teachers.`);

                console.log("Setting up month buttons...");
                setupMonthButtons();

                if (allTeachers.size === 0) { console.warn("No teachers identified..."); statusNow.textContent = 'Warning: No teachers found...'; statusNow.classList.add('error'); populateStaffDropdown(); }
                else { console.log("Populating dropdowns..."); populateStaffDropdown(); statusNow.textContent = `Schedule loaded. Checked for: ${new Date().toLocaleString()}`; }

                console.log("Setting default input values...");
                const now = new Date();
                dateInput.valueAsDate = now; timeFromInput.value = now.toTimeString().substring(0, 5); const later = new Date(now.getTime() + 60 * 60 * 1000); timeToInput.value = later.toTimeString().substring(0, 5); dateEntryInput.valueAsDate = now; yearDisplay.value = now.getFullYear();

                if (absenceDateInput) absenceDateInput.valueAsDate = now;

                if (lessons.length > 0) {
                    console.log("Getting availability for now...");
                    const availabilityNow = getAvailabilityAtTime(now);
                    if (availabilityNow && typeof availabilityNow === 'object' && Array.isArray(availabilityNow.available)) { console.log("Displaying results for now..."); displayResults(availabilityNow.available, availabilityNow.onCallTimes, teachersNowList, statusNow, now); }
                    else { console.error("getAvailabilityAtTime returned invalid data:", availabilityNow); statusNow.textContent = 'Error displaying current availability (invalid data). Check console.'; if (!statusNow.classList.contains('error')) statusNow.classList.add('error'); }
                } else { statusNow.textContent = statusNow.textContent.includes('No teachers found') ? statusNow.textContent : 'Warning: Lessons invalid. Availability check skipped.'; if (!statusNow.classList.contains('error')) statusNow.classList.add('error'); }

                console.log("Setting active month...");
                const currentMonthIndex = now.getMonth();
                if (monthButtonsContainer) {
                    const currentMonthButton = monthButtonsContainer.querySelector(`button[data-month-index="${currentMonthIndex}"]`);
                    if (currentMonthButton) { console.log("Found current month button, clicking..."); currentMonthButton.click(); }
                    else { console.warn(`Could not find button for current month index ${currentMonthIndex} AFTER setup. Attempting manual display.`); displayMonthlyTotals(now.getFullYear(), currentMonthIndex); }
                } else { console.error("Month buttons container not found when trying to set active month."); }

                refreshAbsenceList();
                console.log("Initialization complete.");

            } catch (error) { statusNow.textContent = `Critical Error: ${error.message}. Cannot initialize fully. Check console (F12).`; statusNow.classList.add('error'); console.error("Load Data Error:", error); try { setupMonthButtons(); const now = new Date(); dateEntryInput.valueAsDate = now; yearDisplay.value = now.getFullYear(); populateStaffDropdown(); if (absenceDateInput) absenceDateInput.valueAsDate = now; refreshAbsenceList(); } catch (uiError) { console.error("Critical UI setup error:", uiError); document.body.innerHTML = `<div style="padding: 20px; color: red; font-weight: bold;">Critical Error: ${error.message}. Cannot initialize. Check console (F12).</div>`; } }
        }


        // --- 9. APPLICATION START ---
        // This is the entry point. It waits for the page to be ready,
        // then assigns DOM elements, wires up event listeners, and starts the app.
        document.addEventListener('DOMContentLoaded', () => {
            // --- Assign DOM Elements ---
            statusNow = document.getElementById('status-now');
            teachersNowList = document.getElementById('teachers-now');
            statusCustom = document.getElementById('status-custom');
            teachersCustomList = document.getElementById('teachers-custom');
            checkButton = document.getElementById('check-button');
            dateInput = document.getElementById('date-input');
            timeFromInput = document.getElementById('time-from-input');
            timeToInput = document.getElementById('time-to-input');
            staffSelect = document.getElementById('staff-select');
            dateEntryInput = document.getElementById('date-entry-input');
            minutesInput = document.getElementById('minutes-input');
            saveMinutesButton = document.getElementById('save-minutes-button');
            saveStatus = document.getElementById('save-status');
            yearDisplay = document.getElementById('year-display');
            monthButtonsContainer = document.getElementById('month-buttons');
            totalsDisplay = document.getElementById('totals-display');
            exportSummaryButton = document.getElementById('export-summary-button');
            exportBackupButton = document.getElementById('export-backup-button');
            clearDataButton = document.getElementById('clear-data-button');
            importCsvButton = document.getElementById('import-csv-button');
            csvFileInput = document.getElementById('csv-file-input');
            importStatus = document.getElementById('import-status');
            absenceStaffSelect = document.getElementById('absence-staff-select');
            absenceDateInput = document.getElementById('absence-date-input');
            absenceTimeFromInput = document.getElementById('absence-time-from-input');
            absenceTimeToInput = document.getElementById('absence-time-to-input');
            saveAbsenceButton = document.getElementById('save-absence-button');
            absenceSaveStatus = document.getElementById('absence-save-status');
            existingAbsencesList = document.getElementById('existing-absences-list');
            exportAbsencesButton = document.getElementById('export-absences-button');
            importAbsencesButton = document.getElementById('import-absences-button');
            absenceCsvFileInput = document.getElementById('absence-csv-file-input');
            absenceImportStatus = document.getElementById('absence-import-status');

            // --- Basic DOM check ---
            if (!statusNow || !monthButtonsContainer || !staffSelect || !absenceStaffSelect) {
                console.error("Critical DOM element missing! Cannot proceed.");
                if (statusNow) { statusNow.textContent = "Error: Page structure broken."; statusNow.classList.add('error'); }
                return;
            }
            console.log("All critical DOM elements found.");

            // --- Wire Up Event Listeners ---
            // Availability Check
            checkButton.addEventListener('click', handleCheckAvailability);

            // Minutes Tracking
            saveMinutesButton.addEventListener('click', handleSaveMinutes);
            yearDisplay.addEventListener('change', handleYearChange);

            // Minutes CSV
            exportSummaryButton.addEventListener('click', handleExportSummary);
            exportBackupButton.addEventListener('click', handleExportBackup);
            importCsvButton.addEventListener('click', handleImportMinutesClick);
            csvFileInput.addEventListener('change', handleMinutesFileSelect);
            
            // Absence Tracking
            saveAbsenceButton.addEventListener('click', handleSaveAbsence);
            absenceDateInput.addEventListener('change', refreshAbsenceList); // Just call the refresh function
            existingAbsencesList.addEventListener('click', handleDeleteAbsence);

            // Absence CSV
            exportAbsencesButton.addEventListener('click', handleExportAbsences);
            importAbsencesButton.addEventListener('click', handleImportAbsencesClick);
            absenceCsvFileInput.addEventListener('change', handleAbsenceFileSelect);

            // Data Management
            clearDataButton.addEventListener('click', handleClearData);

            // --- Start the Application ---
            loadData(); // This now includes the migration check
        });
    </script>
</body>
</html>

